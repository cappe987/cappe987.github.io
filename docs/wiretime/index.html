<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Wiretime | Casper Andersson</title>
<meta name=keywords content><meta name=description content=" Measure the time a packet is on the wire accurately using hardware timestamping. Useful for measuring the impact of traffic congestion and QoS. "><meta name=author content><link rel=canonical href=https://casan.se/docs/wiretime/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script src=/js/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=stylesheet href=/css/default.min.css><link rel=icon href=https://casan.se/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://casan.se/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://casan.se/favicon-32x32.png><link rel=apple-touch-icon href=https://casan.se/apple-touch-icon.png><link rel=mask-icon href=https://casan.se/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Wiretime"><meta property="og:description" content=" Measure the time a packet is on the wire accurately using hardware timestamping. Useful for measuring the impact of traffic congestion and QoS. "><meta property="og:type" content="article"><meta property="og:url" content="https://casan.se/docs/wiretime/"><meta property="article:section" content="docs"><meta property="article:published_time" content="2023-04-17T00:00:00+00:00"><meta property="article:modified_time" content="2023-04-17T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Wiretime"><meta name=twitter:description content=" Measure the time a packet is on the wire accurately using hardware timestamping. Useful for measuring the impact of traffic congestion and QoS. "><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Documentation","item":"https://casan.se/docs/"},{"@type":"ListItem","position":2,"name":"Wiretime","item":"https://casan.se/docs/wiretime/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Wiretime","name":"Wiretime","description":" Measure the time a packet is on the wire accurately using hardware timestamping. Useful for measuring the impact of traffic congestion and QoS. ","keywords":[],"articleBody":" Measure the time a packet is on the wire accurately using hardware timestamping. This is useful for measuring the impact of traffic congestion and testing QoS features. The timestamped packets are intended to never touch any software on their trip through the network since that adds considerable delay and jitter, and the benefit of hardware timestamping dwindles. In which case using ping may be enough precision.\nIf you are unfamiliar with timestamping I recommend checking out my post on PTP and timestamping methods.\nGitHub repository\nUsing Wiretime Wiretime requires two interfaces, one for transmission and one for receival. This can be the same physical port by creating two VLAN interfaces on top of the port interface (note that they must be attached directly to the port and not through a bridge as bridges cannot do timestamping). Ideally, Wiretime should be used on a network switch that has multiple interface capable of timestamping. For best accuracy the ports should use the same Physical Hardware Clock (PHC). If they aren’t using the same PHC they need to be precisely synced.\nThe packets will use a path that loops back to the transmitting switch. The receiving port should be set to a different VLAN than the transmitting port, or removed from the bridge completely, to avoid flooding. Packets are timestamped on transmission and receival and the difference is calculated across several packets and the average is taken.\nThe most basic command looks like this\nwiretime --tx eth1 --rx eth2 The following is an illustration of an example setup. Wiretime runs on SW1 and transmits on one port and receives on another. The packet is switched in hardware through SW2, and then back to SW1.\n┌───────┐ │ │ ┌───▲─┐ ┌─▼───┐ │ SW1 │ │ SW2 │ └───▲─┘ └─▼───┘ │ │ └───────┘ Flags -t, --tx Transmit packets on . Can be a VLAN or other interface, as long as the physical port supports hardware timestamping.\n-r, --rx Receive packets on interface . Can be a VLAN or other interface, as long as the physical port supports hardware timestamping.\n-p, --pcp PCP priority. If VLAN is not set it will use VLAN 0.\n-v, --vlan VID to tag the packet with.\n-P, --prio Socket priority. Used to achieve egress QoS.\n-o, --one-step Use one-step TX instead of two-step.\n-O, --out Output data into file for plotting. Use when running Wiretime on a device that does not have Gnuplot installed. The file can then be copied to another device for plotting afterwards.\n-i, --interval Interval between packets. Default: 1000.\n-b, --batch_size Amount of packets to include in every output. Outputs the average time of all packets in the batch. Default: 1.\n-S, --software_tstamp Perform software timestamping instead of hardware timestamping.\n--plot Plots the data using Gnuplot and exports as PDF. If -O is not used it will create a temporary file for storing the data. The same plotting settings also exists as a bash script in the repository.\n--tstamp-all Enable timestamping of non-PTP packets. On some NICs this will behave differently than timestamping PTP packets only. Incompatible with --one-step.\nExample plot Below is an example plot using one-step PHY timestamping taken over 110 seconds. The packets are sent from one switch, through another, and back to the senders receiving port. The total time spent on the wire is around 3500–4000 nanoseconds, or 3.5–4 microseconds.\n","wordCount":"566","inLanguage":"en","datePublished":"2023-04-17T00:00:00Z","dateModified":"2023-04-17T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://casan.se/docs/wiretime/"},"publisher":{"@type":"Organization","name":"Casper Andersson","logo":{"@type":"ImageObject","url":"https://casan.se/favicon.svg"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://casan.se/ accesskey=h title="Casper Andersson (Alt + H)">Casper Andersson</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://casan.se/blog title=Blog><span>Blog</span></a></li><li><a href=https://casan.se/docs title=Docs><span>Docs</span></a></li><li><a href=https://casan.se/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://casan.se/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://casan.se/>Home</a>&nbsp;»&nbsp;<a href=https://casan.se/docs/>Documentation</a></div><h1 class=post-title>Wiretime</h1><ul class=post-tags></ul></header><div class=post-content><style type=text/css>pre>code{display:block!important;line-height:1.3rem!important;font-size:1.3rem!important}</style><p>Measure the time a packet is on the wire accurately using hardware timestamping.
This is useful for measuring the impact of traffic congestion and testing QoS
features. The timestamped packets are intended to never touch any software on
their trip through the network since that adds considerable delay and jitter,
and the benefit of hardware timestamping dwindles. In which case using <code>ping</code>
may be enough precision.</p><p>If you are unfamiliar with timestamping I recommend checking out my post on <a href=https://casan.se/blog/networks/ptp-and-timestamping-methods/>PTP
and timestamping methods</a>.</p><p><a href=https://github.com/cappe987/wiretime>GitHub repository</a></p><h2 id=using-wiretime>Using Wiretime<a hidden class=anchor aria-hidden=true href=#using-wiretime>#</a></h2><p>Wiretime requires two interfaces, one for transmission and one for receival.
This can be the same physical port by creating two VLAN interfaces on top of the
port interface (note that they must be attached directly to the port and not
through a bridge as bridges cannot do timestamping). Ideally, Wiretime should be
used on a network switch that has multiple interface capable of timestamping.
For best accuracy the ports should use the same Physical Hardware Clock (PHC).
If they aren&rsquo;t using the same PHC they need to be precisely synced.</p><p>The packets will use a path that loops back to the transmitting switch. The
receiving port should be set to a different VLAN than the transmitting port, or
removed from the bridge completely, to avoid flooding. Packets are timestamped
on transmission and receival and the difference is calculated across several
packets and the average is taken.</p><p>The most basic command looks like this</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>wiretime --tx eth1 --rx eth2
</span></span></code></pre></div><p>The following is an illustration of an example setup. Wiretime runs on SW1 and
transmits on one port and receives on another. The packet is switched in
hardware through SW2, and then back to SW1.</p><pre tabindex=0><code>    ┌───────┐
    │       │
┌───▲─┐   ┌─▼───┐
│ SW1 │   │ SW2 │
└───▲─┘   └─▼───┘
    │       │
    └───────┘
</code></pre><h3 id=flags>Flags<a hidden class=anchor aria-hidden=true href=#flags>#</a></h3><p><code>-t, --tx &lt;interface></code>
Transmit packets on <code>&lt;interface></code>. Can be a VLAN or other interface,
as long as the physical port supports hardware timestamping.</p><p><code>-r, --rx &lt;interface></code>
Receive packets on interface <code>&lt;interface></code>. Can be a VLAN or other interface,
as long as the physical port supports hardware timestamping.</p><p><code>-p, --pcp &lt;PCP></code>
PCP priority. If VLAN is not set it will use VLAN 0.</p><p><code>-v, --vlan &lt;VID></code>
VID to tag the packet with.</p><p><code>-P, --prio &lt;priority></code>
Socket priority. Used to achieve egress QoS.</p><p><code>-o, --one-step</code>
Use one-step TX instead of two-step.</p><p><code>-O, --out &lt;filename></code>
Output data into file for plotting. Use when running Wiretime on a device that
does not have Gnuplot installed. The file can then be copied to another device
for plotting afterwards.</p><p><code>-i, --interval &lt;milliseconds></code>
Interval between packets. Default: 1000.</p><p><code>-b, --batch_size &lt;count></code>
Amount of packets to include in every output. Outputs the average time of all
packets in the batch. Default: 1.</p><p><code>-S, --software_tstamp</code>
Perform software timestamping instead of hardware timestamping.</p><p><code>--plot &lt;filename></code>
Plots the data using Gnuplot and exports as PDF. If <code>-O</code> is
not used it will create a temporary file for storing the data. The same plotting
settings also exists as a bash script in the repository.</p><p><code>--tstamp-all</code>
Enable timestamping of non-PTP packets. On some NICs this will behave
differently than timestamping PTP packets only. Incompatible with <code>--one-step</code>.</p><h2 id=example-plot>Example plot<a hidden class=anchor aria-hidden=true href=#example-plot>#</a></h2><p>Below is an example plot using one-step PHY timestamping taken over 110 seconds.
The packets are sent from one switch, through another, and back to the senders
receiving port. The total time spent on the wire is around 3500&ndash;4000
nanoseconds, or 3.5&ndash;4 microseconds.</p><p><img loading=lazy src=/docs/img/phy-one-step.png alt="Image of one-step PHY timestamping measurement"></p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://casan.se/>Casper Andersson</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>