<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>A simpler life without sudo | Casper Andersson</title><meta name=keywords content="linux,programming"><meta name=description content="Using Capmon to figure out what capabilities your program needs"><meta name=author content><link rel=canonical href=https://casan.se/blog/a-simpler-life-without-sudo/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script src=/js/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=stylesheet href=/css/default.min.css><link rel=icon href=https://casan.se/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://casan.se/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://casan.se/favicon-32x32.png><link rel=apple-touch-icon href=https://casan.se/apple-touch-icon.png><link rel=mask-icon href=https://casan.se/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="A simpler life without sudo"><meta property="og:description" content="Using Capmon to figure out what capabilities your program needs"><meta property="og:type" content="article"><meta property="og:url" content="https://casan.se/blog/a-simpler-life-without-sudo/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2022-08-26T00:00:00+00:00"><meta property="article:modified_time" content="2022-08-26T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="A simpler life without sudo"><meta name=twitter:description content="Using Capmon to figure out what capabilities your program needs"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://casan.se/blog/"},{"@type":"ListItem","position":2,"name":"A simpler life without sudo","item":"https://casan.se/blog/a-simpler-life-without-sudo/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"A simpler life without sudo","name":"A simpler life without sudo","description":"Using Capmon to figure out what capabilities your program needs","keywords":["linux","programming"],"articleBody":"A couple months ago a colleague showed me his post on a life without sudo. In it he demonstrates the elegant use of Linux capabilities(7). If you aren’t familiar with capabilities I recommend reading his post first. I started using it myself and found it incredibly convenient. I would run sudo many times per day before. This would usually be to do some network-related activity such as sending raw packets or changing network interfaces. These I know require the capabilities CAP_NET_RAW and CAP_NET_ADMIN. But once in a while I come across something where I do not know which capability it uses. Network namespaces was such a thing. Turns out it requires CAP_SYS_ADMIN and CAP_DAC_OVERRIDE.\nTo make my new life without sudo even simpler I wrote capmon - a Linux capabilities monitor. It allows you to monitor the capability checks that Linux does, and is able to filter and aggregate them for you.\nHow it works It makes use of kprobe-based event tracing. The kernel config CONFIG_KPROBE_EVENTS exposes a debugfs (debug file system) that you can interact with by reading and writing to files. It lets you set debug probes (kprobes) on kernel functions and print out information when they are called or returns. In the case of capmon it listens to calls to functions that do capability checks and prints the argument int cap which holds an integer representing the capability it is checking. It also prints the name of the process calling it and its process id (pid). This all ends up in a log file at /sys/kernel/debug/tracing/trace_pipe that capmon actively reads from when data comes in. The data is parsed and presented in a more user-friendly manner.\nIt features three filter options: filter by process name, pid, or capability being checked. Process name supports regular expressions. The filters can be combined freely. Filters of the same type are treated as OR, while filters of different types are treated as AND. Filtering is great, but one feature which I think really helps is the summary mode. Sometimes there can be a lot of output. The summary mode allows you to gather all checks by either process name or pid. At the end it will print out which names/id’s checked which capabilities.\nHow to use it capmon itself uses CAP_DAC_OVERRIDE, in case you don’t want to use sudo for it. If you want to find the capabilities of a program you start by running capmon. Possibly with some filters or flags. Now we will use summary mode to find the required permission. For example:\ncapmon -s name Then you run the program without sudo. Now you can either add the capability you saw pop up in capmon, or stop capmon using to see the summary mode. It may fail on the first capability check and stop there. So you may have to add that capability then run it again to have it fail on the next one.\nIssues As of release 1.1 of capmon there are some issues with the design that I would like to resolve in the future.\nWhat to monitor? Right now it shows more capability checks than necessary, and sometimes it might still not show all you want. This is because capability checks take different paths through the kernel, though they all seem to converge to cap_capable. But cap_capable is called a lot and for things you might not care about. I added that as an extra flag -a. By default it monitors ns_capable and capable_wrt_inode_uidgid. A lot of checks might happen due to capabilities I think the user might have by default. For example, CAP_SYS_PTRACE is called a lot when you run htop. Even though I never explicitly gave that capability.\nInteracting with kprobe events The debugfs interface works fine for manual debugging. But it feels too unstable to be used for an application. It uses a common output file and it could easily break through manually touching the debugfs. Or even if some other application wants to do a similar thing. They might send a clear-all command to the debufs.\nI would like to rewrite this using libbpf, to write proper code that attaches to the functions instead of sending raw strings to files.\n","wordCount":"701","inLanguage":"en","datePublished":"2022-08-26T00:00:00Z","dateModified":"2022-08-26T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://casan.se/blog/a-simpler-life-without-sudo/"},"publisher":{"@type":"Organization","name":"Casper Andersson","logo":{"@type":"ImageObject","url":"https://casan.se/favicon.svg"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://casan.se/ accesskey=h title="Casper Andersson (Alt + H)">Casper Andersson</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://casan.se/blog title=Blog><span>Blog</span></a></li><li><a href=https://casan.se/docs title=Docs><span>Docs</span></a></li><li><a href=https://casan.se/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://casan.se/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://casan.se/>Home</a>&nbsp;»&nbsp;<a href=https://casan.se/blog/>Blog</a></div><h1 class=post-title>A simpler life without sudo</h1><div class=post-meta><span title='2022-08-26 00:00:00 +0000 UTC'>August 26, 2022</span>&nbsp;·&nbsp;4 min</div><ul class=post-tags><li><a href=https://casan.se/tags/linux/>linux</a></li><li><a href=https://casan.se/tags/programming/>programming</a></li></ul></header><div class=post-content><p>A couple months ago a colleague showed me his post on <a href=https://troglobit.com/2016/12/11/a-life-without-sudo/>a life without
sudo</a>. In it he
demonstrates the elegant use of Linux
<a href=http://man7.org/linux/man-pages/man7/capabilities.7.html>capabilities(7)</a>. If
you aren&rsquo;t familiar with capabilities I recommend reading his post first. I
started using it myself and found it incredibly convenient. I would run sudo
many times per day before. This would usually be to do some network-related
activity such as sending raw packets or changing network interfaces. These I
know require the capabilities <code>CAP_NET_RAW</code> and <code>CAP_NET_ADMIN</code>. But once in a
while I come across something where I do not know which capability it uses.
Network namespaces was such a thing. Turns out it requires <code>CAP_SYS_ADMIN</code> and
<code>CAP_DAC_OVERRIDE</code>.</p><p>To make my new life without sudo even simpler I wrote <a href=https://github.com/cappe987/capmon>capmon - a Linux
capabilities monitor</a>. It allows you to
monitor the capability checks that Linux does, and is able to filter and
aggregate them for you.</p><h2 id=how-it-works>How it works<a hidden class=anchor aria-hidden=true href=#how-it-works>#</a></h2><p>It makes use of kprobe-based event tracing. The kernel config
<code>CONFIG_KPROBE_EVENTS</code> exposes a debugfs (debug file system) that you can
interact with by reading and writing to files. It lets you set debug probes
(kprobes) on kernel functions and print out information when they are called or
returns. In the case of capmon it listens to calls to functions that do
capability checks and prints the argument <code>int cap</code> which holds an integer
representing the capability it is checking. It also prints the name of the
process calling it and its process id (pid). This all ends up in a log file at
<code>/sys/kernel/debug/tracing/trace_pipe</code> that capmon actively reads from when
data comes in. The data is parsed and presented in a more user-friendly manner.</p><p>It features three filter options: filter by process name, pid, or capability
being checked. Process name supports regular expressions. The filters can be
combined freely. Filters of the same type are treated as <code>OR</code>, while filters of
different types are treated as <code>AND</code>. Filtering is great, but one feature which
I think really helps is the summary mode. Sometimes there can be a lot of
output. The summary mode allows you to gather all checks by either process name
or pid. At the end it will print out which names/id&rsquo;s checked which
capabilities.</p><h2 id=how-to-use-it>How to use it<a hidden class=anchor aria-hidden=true href=#how-to-use-it>#</a></h2><p><code>capmon</code> itself uses <code>CAP_DAC_OVERRIDE</code>, in case you don&rsquo;t want to use sudo for
it. If you want to find the capabilities of a program you start by running
capmon. Possibly with some filters or flags. Now we will use summary mode to
find the required permission. For example:</p><pre tabindex=0><code>capmon -s name
</code></pre><p>Then you run the program without sudo. Now you can either add the capability you
saw pop up in capmon, or stop capmon using &lt;Ctrl-C> to see the summary mode. It may fail on
the first capability check and stop there. So you may have to add that
capability then run it again to have it fail on the next one.</p><h2 id=issues>Issues<a hidden class=anchor aria-hidden=true href=#issues>#</a></h2><p>As of release 1.1 of capmon there are some issues with the design that I would
like to resolve in the future.</p><h3 id=what-to-monitor>What to monitor?<a hidden class=anchor aria-hidden=true href=#what-to-monitor>#</a></h3><p>Right now it shows more capability checks than necessary, and sometimes it might
still not show all you want. This is because capability checks take different
paths through the kernel, though they all seem to converge to <code>cap_capable</code>. But
<code>cap_capable</code> is called a lot and for things you might not care about. I added
that as an extra flag <code>-a</code>. By default it monitors <code>ns_capable</code> and
<code>capable_wrt_inode_uidgid</code>. A lot of checks might happen due to capabilities I
think the user might have by default. For example, <code>CAP_SYS_PTRACE</code> is called a
lot when you run <code>htop</code>. Even though I never explicitly gave that capability.</p><h3 id=interacting-with-kprobe-events>Interacting with kprobe events<a hidden class=anchor aria-hidden=true href=#interacting-with-kprobe-events>#</a></h3><p>The debugfs interface works fine for manual debugging. But it feels too unstable
to be used for an application. It uses a common output file and it could easily
break through manually touching the debugfs. Or even if some other application
wants to do a similar thing. They might send a clear-all command to the debufs.</p><p>I would like to rewrite this using libbpf, to write proper code that attaches to
the functions instead of sending raw strings to files.</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://casan.se/>Casper Andersson</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>