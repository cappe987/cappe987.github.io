<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Type inference with Hindley-Milner W algorithm | Casper Andersson</title>
<meta name=keywords content="computer_science"><meta name=description content="A demonstration of the Hindley-Milner W Algorithm in F#."><meta name=author content><link rel=canonical href=https://casan.se/blog/computer_science/type-inference-with-hindley-milner-w-algorithm/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script src=/js/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=stylesheet href=/css/default.min.css><link rel=icon href=https://casan.se/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://casan.se/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://casan.se/favicon-32x32.png><link rel=apple-touch-icon href=https://casan.se/apple-touch-icon.png><link rel=mask-icon href=https://casan.se/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Type inference with Hindley-Milner W algorithm"><meta property="og:description" content="A demonstration of the Hindley-Milner W Algorithm in F#."><meta property="og:type" content="article"><meta property="og:url" content="https://casan.se/blog/computer_science/type-inference-with-hindley-milner-w-algorithm/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2020-02-26T00:00:00+00:00"><meta property="article:modified_time" content="2020-02-26T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Type inference with Hindley-Milner W algorithm"><meta name=twitter:description content="A demonstration of the Hindley-Milner W Algorithm in F#."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://casan.se/blog/"},{"@type":"ListItem","position":2,"name":"Computer Science","item":"https://casan.se/blog/computer_science/"},{"@type":"ListItem","position":3,"name":"Type inference with Hindley-Milner W algorithm","item":"https://casan.se/blog/computer_science/type-inference-with-hindley-milner-w-algorithm/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Type inference with Hindley-Milner W algorithm","name":"Type inference with Hindley-Milner W algorithm","description":"A demonstration of the Hindley-Milner W Algorithm in F#.","keywords":["computer_science"],"articleBody":"Introduction The W algorithm developed by J. Hindley and R. Milner is used to infer the types of a programming language where no types have been explicitly written. Several functional languages today use this kind of inference, for exampel F# and Haskell (although Haskellers still like to write out the types). The method works by assuming everything is a different generic type. The types of any pre-existing functions and any constants will be known before starting. So if there is a 0 in the code then that is an integer, 0.0 is a float, [] is a generic list.\nFinding the types Types with an apostrophe before them means they are generic. A type is written with the syntax variable_name : variable_type.\nWe begin with a simple example. Below we have the identity function written in F#. It takes in an element and returns back the same element.\nlet id x = x To calculate the types of this function we start by setting all unknown values to a generic type.\nx : 'a id : 'b -\u003e 'c The variable x has the generic type 'a and the function id has the generic type of 'b -\u003e 'c. Because the input of the function is x and x has the generic type 'a then the function input must also have the same type.\nx : 'a id : 'a -\u003e 'c The only possible output of this function is also the value of x. Thus the return value of the function must also be 'a.\nx : 'a id : 'a -\u003e 'a And now we’re done with that function. All values have been reduced to the same type. There are no further reductions to be done. The identity function has the type 'a -\u003e 'a because it will always return the same value it is given.\nA more complicated example Below we have a function of which we do not know any of the types for.\nlet rec myfunc f xs = match xs with | [] -\u003e [] | x::xs -\u003e f x :: myfunc f xs We start by finding the types of all our constants and pre-existing functions and then giving a generic type to all our unknowns.\n[] : 'a list (::) : 'b -\u003e 'b list -\u003e 'b list f : 'c x : 'd xs : 'e myfunc : 'f We can see that the parameters for myfunc are f and xs. Therefore 'f = 'c -\u003e 'e -\u003e 'g\nf : 'c x : 'd xs : 'e myfunc : 'c -\u003e 'e -\u003e 'g To start figuring out what the types are we can start by looking at the match statement. It matches on xs and the first pattern it suggests that it is of type 'a list. The second pattern is a deconstructing pattern with the cons operator. Because of the :: operator that means x : 'b and xs : 'b list, and the return value of the :: operation and the second pattern match is therefore 'b list. We can therefore say that 'e = 'a list = 'b list, which in turn implies that 'd = 'a = 'b.\nf : 'c x : 'a xs : 'a list myfunc : 'c -\u003e 'a list -\u003e 'g Now there’s only 'c and 'g left to figure out. We’ll start with 'g'. The return value of the first pattern match is an empty list 'h list. Note that this is the second empty list we use and it is not guaranteed to be the same type as the first. Same goes for the :: operator. The second pattern match returns the result of the :: operation, which we’ll call 'i list. If the cons operator is to work on its arguments the left side must be 'i and the right side must be 'i list. Therefore myfunc must return an 'i list. And since the only other return value of myfunc is 'h list we can draw the conclusion that 'g = 'h list = 'i list, which implies 'h = 'i. Since we said earlier that x : 'a and the left input to :: is 'h we know that f : 'a -\u003e 'h.\nf : 'a -\u003e 'h x : 'a xs : 'a list myfunc : ('a -\u003e 'h) -\u003e 'a list -\u003e 'h list And then we fix it up a little by using only the first letters of the alphabet.\nf : 'a -\u003e 'b x : 'a xs : 'a list myfunc : ('a -\u003e 'b) -\u003e 'a list -\u003e 'b list The final type of myfunc is ('a -\u003e 'b) -\u003e 'a list -\u003e 'b list. Any experienced functional programmer should now see what function it is, if they didn’t already see it the second they saw the function definition. It is of course the famous map function, or more specifically the map function for lists.\nIntroducing a type error Now lets say we instead have the same function but a :: switched out for a +.\nlet rec myfunc f xs = match xs with | [] -\u003e [] | x::xs -\u003e f x + myfunc f xs The plus operator has the type (+) : 'num -\u003e 'num -\u003e 'num where 'num symbolizes a generic number type (eg. int, float, double). This would mean that f : 'a -\u003e 'num. But the returning value of myfunc can’t be a 'num because the first case of the pattern match says it’s an 'h list. Now we have reached a type error and compilation can stop here. This code will not compile because the types for + doesn’t match.\nExercise for the reader let exercise l = match l with | [] -\u003e 0 | x::xs -\u003e if x \u003e 0 then x + exercise xs else exercise xs ","wordCount":"980","inLanguage":"en","datePublished":"2020-02-26T00:00:00Z","dateModified":"2020-02-26T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://casan.se/blog/computer_science/type-inference-with-hindley-milner-w-algorithm/"},"publisher":{"@type":"Organization","name":"Casper Andersson","logo":{"@type":"ImageObject","url":"https://casan.se/favicon.svg"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://casan.se/ accesskey=h title="Casper Andersson (Alt + H)">Casper Andersson</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://casan.se/blog title=Blog><span>Blog</span></a></li><li><a href=https://casan.se/docs title=Docs><span>Docs</span></a></li><li><a href=https://casan.se/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://casan.se/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://casan.se/>Home</a>&nbsp;»&nbsp;<a href=https://casan.se/blog/>Blog</a>&nbsp;»&nbsp;<a href=https://casan.se/blog/computer_science/>Computer Science</a></div><h1 class=post-title>Type inference with Hindley-Milner W algorithm</h1><div class=post-meta><span title='2020-02-26 00:00:00 +0000 UTC'>February 26, 2020</span>&nbsp;·&nbsp;5 min</div><ul class=post-tags><li><a href=https://casan.se/tags/computer_science/>computer_science</a></li></ul></header><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>The W algorithm developed by J. Hindley and R. Milner is used to infer the types of a programming language where no types have been explicitly written. Several functional languages today use this kind of inference, for exampel F# and Haskell (although Haskellers still like to write out the types). The method works by assuming everything is a different generic type. The types of any pre-existing functions and any constants will be known before starting. So if there is a <code>0</code> in the code then that is an integer, <code>0.0</code> is a float, <code>[]</code> is a generic list.</p><h2 id=finding-the-types>Finding the types<a hidden class=anchor aria-hidden=true href=#finding-the-types>#</a></h2><p>Types with an apostrophe before them means they are generic. A type is written with the syntax <code>variable_name : variable_type</code>.</p><p>We begin with a simple example. Below we have the identity function written in F#. It takes in an element and returns back the same element.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=k>let</span> <span class=nv>id</span> <span class=n>x</span> <span class=o>=</span> <span class=n>x</span>
</span></span></code></pre></div><p>To calculate the types of this function we start by setting all unknown values to a generic type.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=n>x</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>a</span>
</span></span><span class=line><span class=cl><span class=n>id</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>b</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>c</span>
</span></span></code></pre></div><p>The variable <code>x</code> has the generic type <code>'a</code> and the function <code>id</code> has the generic type of <code>'b -> 'c</code>. Because the input of the function is <code>x</code> and <code>x</code> has the generic type <code>'a</code> then the function input must also have the same type.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=n>x</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>a</span>
</span></span><span class=line><span class=cl><span class=n>id</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>a</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>c</span>
</span></span></code></pre></div><p>The only possible output of this function is also the value of <code>x</code>. Thus the return value of the function must also be <code>'a</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=n>x</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>a</span>
</span></span><span class=line><span class=cl><span class=n>id</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>a</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>a</span>
</span></span></code></pre></div><p>And now we&rsquo;re done with that function. All values have been reduced to the same type. There are no further reductions to be done. The identity function has the type <code>'a -> 'a</code> because it will always return the same value it is given.</p><h2 id=a-more-complicated-example>A more complicated example<a hidden class=anchor aria-hidden=true href=#a-more-complicated-example>#</a></h2><p>Below we have a function of which we do not know any of the types for.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=k>let</span> <span class=nv>rec</span> <span class=n>myfunc</span> <span class=n>f</span> <span class=n>xs</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=k>match</span> <span class=n>xs</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=bp>[]</span>    <span class=o>-&gt;</span> <span class=bp>[]</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=n>x</span><span class=o>::</span><span class=n>xs</span> <span class=o>-&gt;</span> <span class=n>f</span> <span class=n>x</span> <span class=o>::</span> <span class=n>myfunc</span> <span class=n>f</span> <span class=n>xs</span>
</span></span></code></pre></div><p>We start by finding the types of all our constants and pre-existing functions and then giving a generic type to all our unknowns.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=bp>[]</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>a</span> <span class=kt>list</span>
</span></span><span class=line><span class=cl><span class=o>(::)</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>b</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>b</span> <span class=kt>list</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>b</span> <span class=kt>list</span>
</span></span><span class=line><span class=cl><span class=n>f</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>c</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>d</span>
</span></span><span class=line><span class=cl><span class=n>xs</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>e</span>
</span></span><span class=line><span class=cl><span class=n>myfunc</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>f</span>
</span></span></code></pre></div><p>We can see that the parameters for <code>myfunc</code> are <code>f</code> and <code>xs</code>. Therefore <code>'f = 'c -> 'e -> 'g</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=n>f</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>c</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>d</span>
</span></span><span class=line><span class=cl><span class=n>xs</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>e</span>
</span></span><span class=line><span class=cl><span class=n>myfunc</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>c</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>e</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>g</span>
</span></span></code></pre></div><p>To start figuring out what the types are we can start by looking at the <code>match</code> statement. It matches on <code>xs</code> and the first pattern it suggests that it is of type <code>'a list</code>. The second pattern is a deconstructing pattern with the cons operator. Because of the <code>::</code> operator that means <code>x : 'b</code> and <code>xs : 'b list</code>, and the return value of the <code>::</code> operation and the second pattern match is therefore <code>'b list</code>. We can therefore say that <code>'e = 'a list = 'b list</code>, which in turn implies that <code>'d = 'a = 'b</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=n>f</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>c</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>a</span>
</span></span><span class=line><span class=cl><span class=n>xs</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>a</span> <span class=kt>list</span>
</span></span><span class=line><span class=cl><span class=n>myfunc</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>c</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>a</span> <span class=kt>list</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>g</span>
</span></span></code></pre></div><p>Now there&rsquo;s only <code>'c</code> and <code>'g</code> left to figure out. We&rsquo;ll start with <code>'g'</code>. The return value of the first pattern match is an empty list <code>'h list</code>. Note that this is the second empty list we use and it is not guaranteed to be the same type as the first. Same goes for the <code>::</code> operator. The second pattern match returns the result of the <code>::</code> operation, which we&rsquo;ll call <code>'i list</code>. If the cons operator is to work on its arguments the left side must be <code>'i</code> and the right side must be <code>'i list</code>. Therefore myfunc must return an <code>'i list</code>. And since the only other return value of myfunc is <code>'h list</code> we can draw the conclusion that <code>'g = 'h list = 'i list</code>, which implies <code>'h = 'i</code>. Since we said earlier that <code>x : 'a</code> and the left input to <code>::</code> is <code>'h</code> we know that <code>f : 'a -> 'h</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=n>f</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>a</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>h</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>a</span>
</span></span><span class=line><span class=cl><span class=n>xs</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>a</span> <span class=kt>list</span>
</span></span><span class=line><span class=cl><span class=n>myfunc</span> <span class=o>:</span> <span class=o>(</span><span class=k>&#39;</span><span class=n>a</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>h</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>a</span> <span class=kt>list</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>h</span> <span class=kt>list</span>
</span></span></code></pre></div><p>And then we fix it up a little by using only the first letters of the alphabet.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=n>f</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>a</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>b</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>a</span>
</span></span><span class=line><span class=cl><span class=n>xs</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>a</span> <span class=kt>list</span>
</span></span><span class=line><span class=cl><span class=n>myfunc</span> <span class=o>:</span> <span class=o>(</span><span class=k>&#39;</span><span class=n>a</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>b</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>a</span> <span class=kt>list</span> <span class=o>-&gt;</span> <span class=k>&#39;</span><span class=n>b</span> <span class=kt>list</span>
</span></span></code></pre></div><p>The final type of <code>myfunc</code> is <code>('a -> 'b) -> 'a list -> 'b list</code>. Any experienced functional programmer should now see what function it is, if they didn&rsquo;t already see it the second they saw the function definition. It is of course the famous <code>map</code> function, or more specifically the <code>map</code> function for lists.</p><h2 id=introducing-a-type-error>Introducing a type error<a hidden class=anchor aria-hidden=true href=#introducing-a-type-error>#</a></h2><p>Now lets say we instead have the same function but a <code>::</code> switched out for a <code>+</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=k>let</span> <span class=nv>rec</span> <span class=n>myfunc</span> <span class=n>f</span> <span class=n>xs</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=k>match</span> <span class=n>xs</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=bp>[]</span>    <span class=o>-&gt;</span> <span class=bp>[]</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=n>x</span><span class=o>::</span><span class=n>xs</span> <span class=o>-&gt;</span> <span class=n>f</span> <span class=n>x</span> <span class=o>+</span> <span class=n>myfunc</span> <span class=n>f</span> <span class=n>xs</span>
</span></span></code></pre></div><p>The plus operator has the type <code>(+) : 'num -> 'num -> 'num</code> where <code>'num</code> symbolizes a generic number type (eg. int, float, double). This would mean that <code>f : 'a -> 'num</code>. But the returning value of <code>myfunc</code> can&rsquo;t be a <code>'num</code> because the first case of the pattern match says it&rsquo;s an <code>'h list</code>. Now we have reached a type error and compilation can stop here. This code will not compile because the types for <code>+</code> doesn&rsquo;t match.</p><h2 id=exercise-for-the-reader>Exercise for the reader<a hidden class=anchor aria-hidden=true href=#exercise-for-the-reader>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=k>let</span> <span class=nv>exercise</span> <span class=n>l</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=k>match</span> <span class=n>l</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=bp>[]</span>    <span class=o>-&gt;</span> <span class=n>0</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=n>x</span><span class=o>::</span><span class=n>xs</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>x</span> <span class=o>&gt;</span> <span class=n>0</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>      <span class=n>x</span> <span class=o>+</span> <span class=n>exercise</span> <span class=n>xs</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>      <span class=n>exercise</span> <span class=n>xs</span>
</span></span></code></pre></div></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://casan.se/>Casper Andersson</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>