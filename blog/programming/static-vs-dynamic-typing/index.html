<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Static vs dynamic typing | Casper Andersson</title>
<meta name=keywords content="programming"><meta name=description content="Comparing static and dynamic typing and my experiences and opinions."><meta name=author content><link rel=canonical href=https://casan.se/blog/programming/static-vs-dynamic-typing/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script src=/js/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=stylesheet href=/css/default.min.css><link rel=icon href=https://casan.se/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://casan.se/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://casan.se/favicon-32x32.png><link rel=apple-touch-icon href=https://casan.se/apple-touch-icon.png><link rel=mask-icon href=https://casan.se/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Static vs dynamic typing"><meta property="og:description" content="Comparing static and dynamic typing and my experiences and opinions."><meta property="og:type" content="article"><meta property="og:url" content="https://casan.se/blog/programming/static-vs-dynamic-typing/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2019-11-21T00:00:00+00:00"><meta property="article:modified_time" content="2019-11-21T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Static vs dynamic typing"><meta name=twitter:description content="Comparing static and dynamic typing and my experiences and opinions."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://casan.se/blog/"},{"@type":"ListItem","position":2,"name":"Programming","item":"https://casan.se/blog/programming/"},{"@type":"ListItem","position":3,"name":"Static vs dynamic typing","item":"https://casan.se/blog/programming/static-vs-dynamic-typing/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Static vs dynamic typing","name":"Static vs dynamic typing","description":"Comparing static and dynamic typing and my experiences and opinions.","keywords":["programming"],"articleBody":"Static and dynamic typing explained Static typing can find type errors reliably at compile time, which should increase the reliability of the delivered program -- Wikipedia\nA statically typed programming language checks that the types of everything matches. If something doesn’t match, the compiler stops and displays an error. This guarantees type safety to a certain degree, without even running the program. A variable has one type and one type only. It can never change its type. This eliminates a lot of errors, and you can spend less time testing it.\nA language with dynamic type checking has its types checked during runtime. These languages often leave out type declarations in the code, leading to less code to read and write. Checking during runtime adds extra overhead when running, and increases the likelihood of runtime type error. Since it only checks the types it encounters, it won’t validate the types in any execution paths you don’t test.\nThe code snippet below contains two separate execution paths, and depending on what value some_condition holds, the else condition may or may not run.\nif some_condition: print(1 + 1) else: print(1 + \"1\") Someone who has used Python may see that the addition in the else path will throw a type error. A statically typed language would catch the error compile-time. Python, however, has a dynamic type system and will not notice the type error if execution doesn’t go down that path. Imagine the condition being something that evaluates to True 99% of the time. You could continue coding for a good while before noticing your mistake.\nStatically typed languages, while type safe to a certain degree, can still contain dynamically typed parts. Languages that make use of inheritance (eg. C#, Java, C++) tend to mix static and dynamic typing. A variable of type A can also hold an instance of any subclass to A. This works because any subclass of A can do everything that A can do. Although it can’t use the subclass’ additional functionalities while assigned to a variable of the supertype, you can downcast the object to its actual type.\nWhen a variable contains an object of a different type than declared, we speak of actual type (the type of the object, possibly a subclass) vs. apparent type (the type of the variable). Here the dynamic part comes in. Because the actual type of the object may differ from the apparent type, we can’t know at compile-time if we can downcast. Different execution paths may lead to the variable containing a different subclass.\nOnly when we know the actual type of the variable can we tell if the code allows the downcasting or not. If not it usually results in a runtime error.\nStatic typing Statically typed languages tend to have better code completion. With your text editor correctly set up you can get red squiggly lines under a lot of what would result in a compiler error, saving you some time. You can also see the type signatures of variables and functions, reducing the chances of making incorrect assumptions.\nmap(function, iterables) The snippet above shows the type signature for the function map in Python. We can see that it wants a function and an iterable for input, according to the hopefully well-named parameters. Without knowing the meaning of map you can’t tell what arguments you should pass to it. You could somewhat assume what counts as iterable, but it doesn’t classify exactly what defines an iterable. Looking at the function parameter we can’t tell anything about what type the argument should have.\nIEnumerable\u003cR\u003e Select\u003cT,R\u003e(IEnumerable\u003cT\u003e, Func\u003cT,R\u003e) Here we have the type signature for the same function in C#. T and R represents two generic types. We do not care about the actual types of the arguments, as long as all T’s have the same type; and same goes for the R’s.\nFor the first argument you can pass it any C# class that implements the interface IEnumerable of any type T. As opposed to Python, it clearly states what defines an iterable.\nFunc represents a function that takes a value of type T and returns a value of type R. This means that if we pass in a list of integers, we must also pass in a function that takes an integer as input, and we will receive an IEnumerable of type R as output. The compiler will complain if we pass it anything that doesn’t match.\nStatic typing tends to make languages more verbose when explicitly stating the types, but not necessarily. Some languages have a strong type inference.\nmap f [] = [] map f (x:xs) = (f x) : map f xs The snippet above shows a simple implementation of map in Haskell. By analyzing how I’ve used lists, list operators, and functions, it can infer the type signature (a -\u003e b) -\u003e [a] -\u003e [b]. This matches the type signature of C#’s Select, a is the T and b is the R, although the parameters have swapped places. C# has it the other way because there you typically use it by doing someObject.Select(function) on an object, instead of passing in the object as a parameter. Haskell on the other hand, makes use of partial application where it makes more sense to apply the function first.\nDynamic typing Dynamically typed languages, while more overhead, usually have no compilation stage, and can thus run immediately. Compiling a large project can take several seconds, if not minutes. When you first learn a compiled language, the compilation step may not feel like any hindrance; as a small program can take less than a second to compile.\nNo compilation opens up for a new cool possibility for testing your code. A compiled language can only run your test cases as often as you compile; but in a dynamically typed language you can set up your tests to run whenever you save a file. This way you can constantly keep track of if you break something. If, however, you are a save-maniac like me, who hits Ctrl+S every few seconds, you may want to learn to control yourself.\nDynamic typing tends to lead to less verbose languages. Without static type checking, the need to write out types disappears. This lowers the bar for newcomers. A less verbose language with no strict compiler yelling at them usually appears more welcoming. If you compare the previously mentioned code snippets of map in Python to the Select in C#, you can easily guess which one a new programmer would go for.\nMy experiences and opinions I was first introduced to programming through my university when I began studying computer science. The first course taught the statically typed language C, and later on C#. The whole first year consisted of only statically typed languages before finally reaching the dynamically typed JavaScript in a course in web development. Using JavaScript felt odd, there were a lot of features I missed. Mainly the code completion and variable/function suggestions. I ran into a great deal of bugs and unexpected behavior; I guess some of these can be attributed to JavaScript specifically.\nI have tried Python as well, and I had similar experiences to JavaScript with it. So as of now I am on the static side. I am, however, in no way saying that either is better or worse than the other. This just happens to be my opinion on it. Someone who was taught Python as their first language may be more inclined to prefer dynamic type systems.\n","wordCount":"1251","inLanguage":"en","datePublished":"2019-11-21T00:00:00Z","dateModified":"2019-11-21T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://casan.se/blog/programming/static-vs-dynamic-typing/"},"publisher":{"@type":"Organization","name":"Casper Andersson","logo":{"@type":"ImageObject","url":"https://casan.se/favicon.svg"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://casan.se/ accesskey=h title="Casper Andersson (Alt + H)">Casper Andersson</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://casan.se/blog title=Blog><span>Blog</span></a></li><li><a href=https://casan.se/docs title=Docs><span>Docs</span></a></li><li><a href=https://casan.se/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://casan.se/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://casan.se/>Home</a>&nbsp;»&nbsp;<a href=https://casan.se/blog/>Blog</a>&nbsp;»&nbsp;<a href=https://casan.se/blog/programming/>Programming</a></div><h1 class=post-title>Static vs dynamic typing</h1><div class=post-meta><span title='2019-11-21 00:00:00 +0000 UTC'>November 21, 2019</span>&nbsp;·&nbsp;6 min</div><ul class=post-tags><li><a href=https://casan.se/tags/programming/>programming</a></li></ul></header><div class=post-content><h2 id=static-and-dynamic-typing-explained>Static and dynamic typing explained<a hidden class=anchor aria-hidden=true href=#static-and-dynamic-typing-explained>#</a></h2><blockquote><p>Static typing can find type errors reliably at compile time,
which should increase the reliability of the delivered
program -- Wikipedia</p></blockquote><p>A statically typed programming language checks that the types of everything matches. If something doesn&rsquo;t match, the compiler stops and displays an error. This guarantees type safety to a certain degree, without even running the program. A variable has one type and one type only. It can never change its type. This eliminates a lot of errors, and you can spend less time testing it.</p><p>A language with dynamic type checking has its types checked during runtime. These languages often leave out type declarations in the code, leading to less code to read and write. Checking during runtime adds extra overhead when running, and increases the likelihood of runtime type error. Since it only checks the types it encounters, it won&rsquo;t validate the types in any execution paths you don&rsquo;t test.</p><p>The code snippet below contains two separate execution paths, and depending on what value <code>some_condition</code> holds, the <code>else</code> condition may or may not run.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=k>if</span> <span class=n>some_condition</span><span class=p>:</span>
</span></span><span class=line><span class=cl>   <span class=nb>print</span><span class=p>(</span><span class=mi>1</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>   <span class=nb>print</span><span class=p>(</span><span class=mi>1</span> <span class=o>+</span> <span class=s2>&#34;1&#34;</span><span class=p>)</span> 
</span></span></code></pre></div><p>Someone who has used Python may see that the addition in the <code>else</code> path will throw a type error. A statically typed language would catch the error compile-time. Python, however, has a dynamic type system and will not notice the type error if execution doesn&rsquo;t go down that path. Imagine the condition being something that evaluates to <code>True</code> 99% of the time. You could continue coding for a good while before noticing your mistake.</p><p>Statically typed languages, while type safe to a certain degree, can still contain dynamically typed parts. Languages that make use of inheritance (eg. C#, Java, C++) tend to mix static and dynamic typing. A variable of type A can also hold an instance of any subclass to A. This works because any subclass of A can do everything that A can do. Although it can&rsquo;t use the subclass&rsquo; additional functionalities while assigned to a variable of the supertype, you can downcast the object to its actual type.</p><p>When a variable contains an object of a different type than declared, we speak of actual type (the type of the object, possibly a subclass) vs. apparent type (the type of the variable). Here the dynamic part comes in. Because the actual type of the object may differ from the apparent type, we can&rsquo;t know at compile-time if we can downcast. Different execution paths may lead to the variable containing a different subclass.</p><p>Only when we know the actual type of the variable can we tell if the code allows the downcasting or not. If not it usually results in a runtime error.</p><h2 id=static-typing>Static typing<a hidden class=anchor aria-hidden=true href=#static-typing>#</a></h2><p>Statically typed languages tend to have better code completion. With your text editor correctly set up you can get red squiggly lines under a lot of what would result in a compiler error, saving you some time. You can also see the type signatures of variables and functions, reducing the chances of making incorrect assumptions.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=nb>map</span><span class=p>(</span><span class=n>function</span><span class=p>,</span> <span class=n>iterables</span><span class=p>)</span>
</span></span></code></pre></div><p>The snippet above shows the type signature for the function <code>map</code> in Python. We can see that it wants a function and an iterable for input, according to the hopefully well-named parameters. Without knowing the meaning of map you can&rsquo;t tell what arguments you should pass to it. You could somewhat assume what counts as iterable, but it doesn&rsquo;t classify exactly what defines an iterable. Looking at the function parameter we can&rsquo;t tell anything about what type the argument should have.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=n>IEnumerable</span><span class=p>&lt;</span><span class=n>R</span><span class=p>&gt;</span> <span class=n>Select</span><span class=p>&lt;</span><span class=n>T</span><span class=p>,</span><span class=n>R</span><span class=p>&gt;(</span><span class=n>IEnumerable</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;,</span> <span class=n>Func</span><span class=p>&lt;</span><span class=n>T</span><span class=p>,</span><span class=n>R</span><span class=p>&gt;)</span>
</span></span></code></pre></div><p>Here we have the type signature for the same function in C#. <code>T</code> and <code>R</code> represents two generic types. We do not care about the actual types of the arguments, as long as all <code>T</code>&rsquo;s have the same type; and same goes for the <code>R</code>&rsquo;s.</p><p>For the first argument you can pass it any C# class that implements the interface <code>IEnumerable&lt;T></code> of any type <code>T</code>. As opposed to Python, it clearly states what defines an iterable.</p><p><code>Func&lt;T,R></code> represents a function that takes a value of type <code>T</code> and returns a value of type <code>R</code>. This means that if we pass in a list of integers, we must also pass in a function that takes an integer as input, and we will receive an <code>IEnumerable</code> of type <code>R</code> as output. The compiler will complain if we pass it anything that doesn&rsquo;t match.</p><p>Static typing tends to make languages more verbose when explicitly stating the types, but not necessarily. Some languages have a strong type inference.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-hs data-lang=hs><span class=line><span class=cl><span class=nf>map</span> <span class=n>f</span> <span class=kt>[]</span> <span class=ow>=</span> <span class=kt>[]</span>
</span></span><span class=line><span class=cl><span class=nf>map</span> <span class=n>f</span> <span class=p>(</span><span class=n>x</span><span class=kt>:</span><span class=n>xs</span><span class=p>)</span> <span class=ow>=</span> <span class=p>(</span><span class=n>f</span> <span class=n>x</span><span class=p>)</span> <span class=kt>:</span> <span class=n>map</span> <span class=n>f</span> <span class=n>xs</span>
</span></span></code></pre></div><p>The snippet above shows a simple implementation of <code>map</code> in Haskell. By analyzing how I&rsquo;ve used lists, list operators, and functions, it can infer the type signature <code>(a -> b) -> [a] -> [b]</code>. This matches the type signature of C#&rsquo;s <code>Select</code>, <code>a</code> is the <code>T</code> and <code>b</code> is the <code>R</code>, although the parameters have swapped places. C# has it the other way because there you typically use it by doing <code>someObject.Select(function)</code> on an object, instead of passing in the object as a parameter. Haskell on the other hand, makes use of partial application where it makes more sense to apply the function first.</p><h2 id=dynamic-typing>Dynamic typing<a hidden class=anchor aria-hidden=true href=#dynamic-typing>#</a></h2><p>Dynamically typed languages, while more overhead, usually have no compilation stage, and can thus run immediately. Compiling a large project can take several seconds, if not minutes. When you first learn a compiled language, the compilation step may not feel like any hindrance; as a small program can take less than a second to compile.</p><p>No compilation opens up for a new cool possibility for testing your code. A compiled language can only run your test cases as often as you compile; but in a dynamically typed language you can set up your tests to run whenever you save a file. This way you can constantly keep track of if you break something. If, however, you are a save-maniac like me, who hits Ctrl+S every few seconds, you may want to learn to control yourself.</p><p>Dynamic typing tends to lead to less verbose languages. Without static type checking, the need to write out types disappears. This lowers the bar for newcomers. A less verbose language with no strict compiler yelling at them usually appears more welcoming. If you compare the previously mentioned code snippets of <code>map</code> in Python to the <code>Select</code> in C#, you can easily guess which one a new programmer would go for.</p><h2 id=my-experiences-and-opinions>My experiences and opinions<a hidden class=anchor aria-hidden=true href=#my-experiences-and-opinions>#</a></h2><p>I was first introduced to programming through my university when I began studying computer science. The first course taught the statically typed language C, and later on C#. The whole first year consisted of only statically typed languages before finally reaching the dynamically typed JavaScript in a course in web development. Using JavaScript felt odd, there were a lot of features I missed. Mainly the code completion and variable/function suggestions. I ran into a great deal of bugs and unexpected behavior; I guess some of these can be attributed to JavaScript specifically.</p><p>I have tried Python as well, and I had similar experiences to JavaScript with it. So as of now I am on the static side. I am, however, in no way saying that either is better or worse than the other. This just happens to be my opinion on it. Someone who was taught Python as their first language may be more inclined to prefer dynamic type systems.</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://casan.se/>Casper Andersson</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>