<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Buildroot and U-boot on Raspberry Pi | Casper Andersson</title>
<meta name=keywords content="linux,programming"><meta name=description content=" When doing development of the OS, flashing your SD card after every change is not reasonable. Instead, use U-boot to allow booting over the network. In this post I go over configuring Buildroot to build U-boot and configure it for a Raspberry Pi. "><meta name=author content><link rel=canonical href=https://casan.se/blog/linux/buildroot-and-u-boot-on-raspberry-pi/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://casan.se/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://casan.se/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://casan.se/favicon-32x32.png><link rel=apple-touch-icon href=https://casan.se/apple-touch-icon.png><link rel=mask-icon href=https://casan.se/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://casan.se/blog/linux/buildroot-and-u-boot-on-raspberry-pi/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://casan.se/blog/"},{"@type":"ListItem","position":2,"name":"Linux","item":"https://casan.se/blog/linux/"},{"@type":"ListItem","position":3,"name":"Buildroot and U-boot on Raspberry Pi","item":"https://casan.se/blog/linux/buildroot-and-u-boot-on-raspberry-pi/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Buildroot and U-boot on Raspberry Pi","name":"Buildroot and U-boot on Raspberry Pi","description":" When doing development of the OS, flashing your SD card after every change is not reasonable. Instead, use U-boot to allow booting over the network. In this post I go over configuring Buildroot to build U-boot and configure it for a Raspberry Pi. ","keywords":["linux","programming"],"articleBody":"This post guides you through setting up Buildroot together with U-boot on your Raspberry Pi and loading a kernel through U-boot (rootfs is separate and still needs to be flashed). Having a dedicated bootloader allows controlling the boot process without having to flash the SD card every time. I wrote this post because I didn’t find any guide when doing so myself, only a couple of posts that partially did it. None of which fully covered my needs. I have a Raspberry Pi 4 and that’s all this guide is tested with.\nThis guide requires having a serial console connection to the Raspberry Pi. It also requires having a TFTP server if you wish to boot over the network.\nBuilding the image with Buildroot Start by cloning Buildroot and cd into it.\ngit clone https://github.com/buildroot/buildroot.git cd buildroot Next we will select the defconfig corresponding to our board. I’m using a Raspberry Pi 4b and wish to use the 64-bit version so I pick this one.\nmake raspberrypi4_64_defconfig If you do ls configs/raspberrypi* you get a list of all available versions.\nNext we will configure some things with the build system through a menu.\nmake menuconfig Go to “Bootloaders” and enable “U-boot”. Under the “U-boot” section, select “Board defconfig”. For the Pi 4 you write rpi_4 here. This is the only required setting for this tutorial, but I highly recommend doing the following steps too. Go to “Toolchain \u003e Toolchain Type” and set “External toolchain”. This allow us to skip building the whole toolchain. Go to “Toolchain \u003e Toolchain” and under “Toolchain External Options” header select “Bootlin Toolchains” (my recommendation). Go to “Build options” and select “Enable compiler cache”. This will improve the build time if you have to do full rebuilds later on. (Optional) Go to “System Configuration \u003e System hostname” and set whatever hostname you want. These are the U-boot configs available for Raspberry Pi at the time of writing.\nrpi_defconfig rpi_0_w_defconfig rpi_2_defconfig rpi_3_32b_defconfig rpi_3_defconfig rpi_3_b_plus_defconfig rpi_4_32b_defconfig rpi_4_defconfig rpi_arm64_defconfig Note that the _defconfig section should not be included when setting the defconfig for U-boot.\nNow we have all required Buildroot settings, but some modifications are still required to prepare the image correctly.\nIn the file board/raspberrypi/config_4_64bit.txt (or corresponding file for your version of the Pi) change the line kernel=Image to kernel=u-boot.bin. The config.txt files configures the built-in Raspberry Pi bootloader. We’re telling it to boot into U-boot instead of directly to a kernel image.\nBecause of the change above we now need to make sure the kernel image is included in the final image too. In the file board/raspberrypi/post-image.sh there is the following line.\nFILES+=( \"${KERNEL}\" ) This is corresponds to the kernel= from the previous file, that we just set to u-boot.bin. Below this line, add the line FILES+=( \"Image\" ).\nNow we are ready to build everything. This can take some time. Maybe 20-30 minutes?\nmake Once everything is done building there should be a file output/images/sdcard.img.\nFlashing the SD card The command lsblk can be used to list all block devices. Insert your SD card into your computer and you should see it pop up in the list. For me it’s called mmcblk0.\nTo flash the SD card run the following command. Make sure to use the name of your SD card in place of mmcblk0.\nNote: flashing is a destructive operation and will erase everything on the card.\nsudo dd if=output/images/sdcard.img of=/dev/mmcblk0 bs=1M Insert the SD card into your Raspberry Pi and power it on. In the console you should see some U-boot output popping up. It will attempt to boot a kernel, but should fail. Before U-boot tries to boot the kernel there is a 3 second countdown where you can press any key to stop the boot process if you wish (useful in the next section).\nConfiguring U-boot and booting from SD card and network Enter the following two commands into the console. The first loads the kernel image into memory. The second boots the image. Now you should see a message saying “Starting kernel …” followed by a lot more output, and finally a login prompt. The default login is the username root with no password. This can be configured in the menuconfig in the same place as the hostname.\nfatload mmc 0 ${kernel_addr_r} Image booti ${kernel_addr_r} - ${fdt_addr} Hopefully this booted the kernel for you. Let’s take a look at booting over the network. This requires a TFTP server, and ideally also a DHCP server. If you don’t have a DHCP server you can set static IPs.\ndhcp ${kernel_addr_r} Image booti ${kernel_addr_r} - ${fdt_addr} setenv serverip '10.0.0.1' setenv ipaddr '10.0.0.101' tftp ${kernel_addr_r} Image booti ${kernel_addr_r} - ${fdt_addr} Note that any setenv we did is gone after rebooting. Run saveenv to preserve it. Next we will set up some commands to make it automatically boot from flash or network.\nsetenv netboot_filename 'Image' setenv netboot 'dhcp ${kernel_addr_r} ${netboot_filename}; booti ${kernel_addr_r} - ${fdt_addr}' setenv sdboot 'fatload mmc 0 ${kernel_addr_r} Image; booti ${kernel_addr_r} - ${fdt_addr}' setenv bootcmd 'run sdboot' saveenv bootcmd decides what is run to attempt booting. We define one variable for the filename which can be convenient to change when working with images over the network. The variable netboot is the full command for booting over the network, and sdboot is for booting from SD card. Now bootcmd is set to boot from SD card, but we can easily change it with setenv bootcmd 'run netboot', followed by saveenv, to boot over the network instead.\nKeep in mind, if you flash the whole sdcard.img again it will wipe the U-boot config, as well as any files in the Linux root file system.\nAs a final step, save your defconfig for later.\nmake savedefconfig BR2_DEFCONFIG=configs/my_defconfig I may do a follow up post on some more advanced configuration options. Some ideas are:\nModifying partition sizes Built-in U-boot environment Updating the flashed image from within Linux Including a filesystem in the kernel image ","wordCount":"987","inLanguage":"en","datePublished":"2024-12-22T00:00:00Z","dateModified":"2024-12-22T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://casan.se/blog/linux/buildroot-and-u-boot-on-raspberry-pi/"},"publisher":{"@type":"Organization","name":"Casper Andersson","logo":{"@type":"ImageObject","url":"https://casan.se/favicon.svg"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://casan.se/ accesskey=h title="Casper Andersson (Alt + H)">Casper Andersson</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://casan.se/blog title=Blog><span>Blog</span></a></li><li><a href=https://casan.se/docs title=Docs><span>Docs</span></a></li><li><a href=https://casan.se/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://casan.se/about/ title="About Me"><span>About Me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://casan.se/>Home</a>&nbsp;»&nbsp;<a href=https://casan.se/blog/>Blog</a>&nbsp;»&nbsp;<a href=https://casan.se/blog/linux/>Linux</a></div><h1 class=post-title>Buildroot and U-boot on Raspberry Pi</h1><div class=post-meta><span title='2024-12-22 00:00:00 +0000 UTC'>December 22, 2024</span>&nbsp;·&nbsp;5 min</div><ul class=post-tags><li><a href=https://casan.se/tags/linux/>Linux</a></li><li><a href=https://casan.se/tags/programming/>Programming</a></li></ul></header><div class=post-content><p>This post guides you through setting up Buildroot together with U-boot
on your Raspberry Pi and loading a kernel through U-boot (rootfs is
separate and still needs to be flashed). Having a dedicated bootloader
allows controlling the boot process without having to flash the SD
card every time. I wrote this post because I didn&rsquo;t find any guide
when doing so myself, only a couple of posts that partially did
it. None of which fully covered my needs. I have a Raspberry Pi 4 and
that&rsquo;s all this guide is tested with.</p><p>This guide requires having a serial console connection to the
Raspberry Pi. It also requires having a TFTP server if you wish to
boot over the network.</p><h2 id=building-the-image-with-buildroot>Building the image with Buildroot<a hidden class=anchor aria-hidden=true href=#building-the-image-with-buildroot>#</a></h2><p>Start by cloning Buildroot and <code>cd</code> into it.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>git clone https://github.com/buildroot/buildroot.git
</span></span><span class=line><span class=cl><span class=nb>cd</span> buildroot
</span></span></code></pre></div><p>Next we will select the defconfig corresponding to our board. I&rsquo;m
using a Raspberry Pi 4b and wish to use the 64-bit version so I pick
this one.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>make raspberrypi4_64_defconfig
</span></span></code></pre></div><p>If you do <code>ls configs/raspberrypi*</code> you get a list of all available
versions.</p><p>Next we will configure some things with the build system through a
menu.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>make menuconfig
</span></span></code></pre></div><ol><li>Go to &ldquo;Bootloaders&rdquo; and enable &ldquo;U-boot&rdquo;. Under the &ldquo;U-boot&rdquo;
section, select &ldquo;Board defconfig&rdquo;. For the Pi 4 you write <code>rpi_4</code>
here. This is the only required setting for this tutorial, but I
highly recommend doing the following steps too.</li><li>Go to &ldquo;Toolchain > Toolchain Type&rdquo; and set &ldquo;External toolchain&rdquo;. This
allow us to skip building the whole toolchain.</li><li>Go to &ldquo;Toolchain > Toolchain&rdquo; and under &ldquo;Toolchain External Options&rdquo;
header select &ldquo;Bootlin Toolchains&rdquo; (my recommendation).</li><li>Go to &ldquo;Build options&rdquo; and select &ldquo;Enable compiler cache&rdquo;. This will
improve the build time if you have to do full rebuilds later on.</li><li>(Optional) Go to &ldquo;System Configuration > System hostname&rdquo; and set whatever
hostname you want.</li></ol><p>These are the U-boot configs available for Raspberry Pi at the time of writing.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>rpi_defconfig
</span></span><span class=line><span class=cl>rpi_0_w_defconfig
</span></span><span class=line><span class=cl>rpi_2_defconfig
</span></span><span class=line><span class=cl>rpi_3_32b_defconfig
</span></span><span class=line><span class=cl>rpi_3_defconfig
</span></span><span class=line><span class=cl>rpi_3_b_plus_defconfig
</span></span><span class=line><span class=cl>rpi_4_32b_defconfig
</span></span><span class=line><span class=cl>rpi_4_defconfig
</span></span><span class=line><span class=cl>rpi_arm64_defconfig
</span></span></code></pre></div><p>Note that the <code>_defconfig</code> section should not be included when setting
the defconfig for U-boot.</p><p>Now we have all required Buildroot settings, but some modifications
are still required to prepare the image correctly.</p><p>In the file <code>board/raspberrypi/config_4_64bit.txt</code> (or corresponding
file for your version of the Pi) change the line <code>kernel=Image</code> to
<code>kernel=u-boot.bin</code>. The <code>config.txt</code> files configures the built-in
Raspberry Pi bootloader. We&rsquo;re telling it to boot into U-boot instead
of directly to a kernel image.</p><p>Because of the change above we now need to make sure the kernel image
is included in the final image too. In the file
<code>board/raspberrypi/post-image.sh</code> there is the following line.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=nv>FILES</span><span class=o>+=(</span> <span class=s2>&#34;</span><span class=si>${</span><span class=nv>KERNEL</span><span class=si>}</span><span class=s2>&#34;</span> <span class=o>)</span>
</span></span></code></pre></div><p>This is corresponds to the <code>kernel=</code> from the previous file, that we
just set to <code>u-boot.bin</code>. Below this line, add the line <code>FILES+=( "Image" )</code>.</p><p>Now we are ready to build everything. This can take some time. Maybe 20-30 minutes?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>make
</span></span></code></pre></div><p>Once everything is done building there should be a file <code>output/images/sdcard.img</code>.</p><h2 id=flashing-the-sd-card>Flashing the SD card<a hidden class=anchor aria-hidden=true href=#flashing-the-sd-card>#</a></h2><p>The command <code>lsblk</code> can be used to list all block devices. Insert your
SD card into your computer and you should see it pop up in the
list. For me it&rsquo;s called <code>mmcblk0</code>.</p><p>To flash the SD card run the following command. Make sure to use the
name of your SD card in place of <code>mmcblk0</code>.</p><blockquote><p>Note: flashing is a destructive operation and will erase everything on the card.</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>sudo dd <span class=k>if</span><span class=o>=</span>output/images/sdcard.img <span class=nv>of</span><span class=o>=</span>/dev/mmcblk0 <span class=nv>bs</span><span class=o>=</span>1M
</span></span></code></pre></div><p>Insert the SD card into your Raspberry Pi and power it on. In the
console you should see some U-boot output popping up. It will attempt
to boot a kernel, but should fail. Before U-boot tries to boot the
kernel there is a 3 second countdown where you can press any key to
stop the boot process if you wish (useful in the next section).</p><h2 id=configuring-u-boot-and-booting-from-sd-card-and-network>Configuring U-boot and booting from SD card and network<a hidden class=anchor aria-hidden=true href=#configuring-u-boot-and-booting-from-sd-card-and-network>#</a></h2><p>Enter the following two commands into the console. The first loads the
kernel image into memory. The second boots the image. Now you should
see a message saying &ldquo;Starting kernel &mldr;&rdquo; followed by a lot more
output, and finally a login prompt. The default login is the username
<code>root</code> with no password. This can be configured in the menuconfig in
the same place as the hostname.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>fatload mmc <span class=m>0</span> <span class=si>${</span><span class=nv>kernel_addr_r</span><span class=si>}</span> Image
</span></span><span class=line><span class=cl>booti <span class=si>${</span><span class=nv>kernel_addr_r</span><span class=si>}</span> - <span class=si>${</span><span class=nv>fdt_addr</span><span class=si>}</span>
</span></span></code></pre></div><p>Hopefully this booted the kernel for you. Let&rsquo;s take a look at booting
over the network. This requires a TFTP server, and ideally also a DHCP
server. If you don&rsquo;t have a DHCP server you can set static IPs.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>dhcp <span class=si>${</span><span class=nv>kernel_addr_r</span><span class=si>}</span> Image
</span></span><span class=line><span class=cl>booti <span class=si>${</span><span class=nv>kernel_addr_r</span><span class=si>}</span> - <span class=si>${</span><span class=nv>fdt_addr</span><span class=si>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>setenv serverip <span class=s1>&#39;10.0.0.1&#39;</span>
</span></span><span class=line><span class=cl>setenv ipaddr <span class=s1>&#39;10.0.0.101&#39;</span>
</span></span><span class=line><span class=cl>tftp <span class=si>${</span><span class=nv>kernel_addr_r</span><span class=si>}</span> Image
</span></span><span class=line><span class=cl>booti <span class=si>${</span><span class=nv>kernel_addr_r</span><span class=si>}</span> - <span class=si>${</span><span class=nv>fdt_addr</span><span class=si>}</span>
</span></span></code></pre></div><p>Note that any <code>setenv</code> we did is gone after rebooting. Run <code>saveenv</code>
to preserve it. Next we will set up some commands to make it
automatically boot from flash or network.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>setenv netboot_filename <span class=s1>&#39;Image&#39;</span>
</span></span><span class=line><span class=cl>setenv netboot <span class=s1>&#39;dhcp ${kernel_addr_r} ${netboot_filename}; booti ${kernel_addr_r} - ${fdt_addr}&#39;</span>
</span></span><span class=line><span class=cl>setenv sdboot <span class=s1>&#39;fatload mmc 0 ${kernel_addr_r} Image; booti ${kernel_addr_r} - ${fdt_addr}&#39;</span>
</span></span><span class=line><span class=cl>setenv bootcmd <span class=s1>&#39;run sdboot&#39;</span>
</span></span><span class=line><span class=cl>saveenv
</span></span></code></pre></div><p><code>bootcmd</code> decides what is run to attempt booting. We define one
variable for the filename which can be convenient to change when
working with images over the network. The variable <code>netboot</code> is the
full command for booting over the network, and <code>sdboot</code> is for booting
from SD card. Now <code>bootcmd</code> is set to boot from SD card, but we can
easily change it with <code>setenv bootcmd 'run netboot'</code>, followed by
<code>saveenv</code>, to boot over the network instead.</p><p>Keep in mind, if you flash the whole sdcard.img again it will wipe the
U-boot config, as well as any files in the Linux root file system.</p><p>As a final step, save your defconfig for later.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>make savedefconfig <span class=nv>BR2_DEFCONFIG</span><span class=o>=</span>configs/my_defconfig
</span></span></code></pre></div><p>I may do a follow up post on some more advanced configuration options.
Some ideas are:</p><ul><li>Modifying partition sizes</li><li>Built-in U-boot environment</li><li>Updating the flashed image from within Linux</li><li>Including a filesystem in the kernel image</li></ul></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://casan.se/>Casper Andersson</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>