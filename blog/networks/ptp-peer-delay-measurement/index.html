<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>PTP peer delay measurement | Casper Andersson</title>
<meta name=keywords content="networks"><meta name=description content="Methods of measuring peer delay"><meta name=author content><link rel=canonical href=https://casan.se/blog/networks/ptp-peer-delay-measurement/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script src=/js/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=stylesheet href=/css/default.min.css><link rel=icon href=https://casan.se/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://casan.se/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://casan.se/favicon-32x32.png><link rel=apple-touch-icon href=https://casan.se/apple-touch-icon.png><link rel=mask-icon href=https://casan.se/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="PTP peer delay measurement"><meta property="og:description" content="Methods of measuring peer delay"><meta property="og:type" content="article"><meta property="og:url" content="https://casan.se/blog/networks/ptp-peer-delay-measurement/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2023-10-12T00:00:00+00:00"><meta property="article:modified_time" content="2023-10-12T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="PTP peer delay measurement"><meta name=twitter:description content="Methods of measuring peer delay"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://casan.se/blog/"},{"@type":"ListItem","position":2,"name":"Networks","item":"https://casan.se/blog/networks/"},{"@type":"ListItem","position":3,"name":"PTP peer delay measurement","item":"https://casan.se/blog/networks/ptp-peer-delay-measurement/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"PTP peer delay measurement","name":"PTP peer delay measurement","description":"Methods of measuring peer delay","keywords":["networks"],"articleBody":"To accurately synchronize the time we need to account for all time lost as the packet travels. One part of this is the time it takes for packets to travel across the cable, including egress time after the timestamp is taken, and ingress time before the timestamp is taken. Though measuring the time it takes from one device to another is impossible because they will never have the exact same time, so a timestamp on one side is not guaranteed to match up with a timestamp on the other side. We have to settle for measuring the roundtrip time and dividing it by 2, and hope that the delay is symmetric.\nTwo-step peer delay This is similar to how two-step for synchronization works, we send a packet, timestamp the egress time, and send a follow-up packet containing the egress time of the first. Two-step peer delay can be done in two different ways, but let us explore the concept first.\nTwo-step using full timestamps Two devices running PTP in peer delay mode will both measure the peer delay independently. But here I will focus on the transaction from the perspective of one side. Call one side client and the other side the server. In reality, both will be both client and server.\nClient sends a peer delay request PDELAY_REQ. It is timestamped t1 on egress and kept by the client. Server receives PDELAY_REQ and timestamps it t2. Server sends a peer delay response PDELAY_RESP containing t2. It is timestamped t3. Client receives PDELAY_RESP containing t2. It is timestamped t4. Server sends a peer delay response follow-up PDELAY_RESP_FUP containing t3. Client receives PDELAY_RESP_FUP containing t3. Now the client has all 4 timestamps:\nt1: egress time of request t2: ingress time of request t3: egress time of response t4: ingress time of response ________t1 t2________ |Client|\u003e-----\u003e|Server| |______|\u003c-----\u003c|______| t4 t3 The formula for calculating the peer delay (meanPathDelay) time looks like this\nmeanPathDelay = ((t4-t1) - (t3-t2))/2 t3-t2 represents the time it spent inside the server device, often called residence time. t4-t1 represents the total time the packet was away. The total time on the wire is then found by subtracting the residence time from the total time. Dividing by 2 gives the mean delay.\nTwo-step using correctionField In this method all the timestamps are still taken the same way as above. But instead of sending the timestamps back, those fields are simply set to zero, and the time t3-t2 is added to correctionField of the PDELAY_RESP_FUP.\nThe full formula is actually slightly longer than what was shown above, to allow for other forms of compensation\nmeanPathDelay = ((t4-t1) - (t3-t2) - pdelay_resp.correction - pdelay_resp_fup.correction)/2 Here we will now have t2 and t3 set to zero on the clients side. And that time instead comes in the pdelay_resp_fup.correction. The end result is the same. And the server side can choose which method to use since it doesn’t matter to the client.\nCorrectionField contains a number of nanoseconds that should be subtracted by the receiver. This exists to allow other forms of compensation as well. The Switchcore or PHY may add compensation for the time it introduces after timestamping.\nOne-step peer delay This works similar to one-step synchronization, and uses the correctionField approach explained above. For this the response ingress timestamp t2 is placed in the reserved2 field (4 bytes) before the response is sent. This field is smaller than the full timestamp, so it only has 2^32 time units to send the response. Past that it will no longer match to the correct ingress time. If the time units are nanoseconds then it calculates to ~4.3 seconds, which is plenty of time to send a response.\nOn egress, the timestamp t3 is taken, and t3-t2 is added to the correctionField on the fly. Now the residence time is calculated and sent back to the client, which now uses the following formula\nmeanPathDelay = ((t4-t1) - pdelay_resp.correction)/2 Note that the full formula from above can still be used, as the unused values will be 0 (and there will be no follow-up).\n1.5-step peer delay This is a combination of two-step and one-step, and can be applied to both sync and peer delay1. The idea is that the protocol still behaves the same as two-step. I.e. it sends follow-up packets. The difference here is that the timestamp, e.g. t1, is just kept in the timestamping hardware and is not read out by the CPU. When the matching follow-up (requesting port ID and sequence ID matches) comes to the hardware the timestamp is filled in. When it goes on the wire it now looks like a normal two-step.\nThe benefit of this is because one-step adds latency to the transmission as it has to stop, take the timestamp just before transmitting, and then modify the packet. At speeds of 10Gbit and higher it starts affecting the transmission speed. The follow-up doesn’t have to be modified exactly at transmission time, it can be prepared ahead of time so it doesn’t affect the latency. By eliminating the readout it minimizes the overhead of sending packets. Meaning the follow-up packet can be sent immediately after the initial sync/pdelay_resp.\n1.5-step is not formulated in any standard because it does not affect the perception. From a protocol point-of-view it is still two-step.\nhttps://www.ieee802.org/1/files/public/docs2015/ASRev-pannell-To-1-step-or-not-0315-v1.pdf ↩︎\n","wordCount":"882","inLanguage":"en","datePublished":"2023-10-12T00:00:00Z","dateModified":"2023-10-12T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://casan.se/blog/networks/ptp-peer-delay-measurement/"},"publisher":{"@type":"Organization","name":"Casper Andersson","logo":{"@type":"ImageObject","url":"https://casan.se/favicon.svg"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://casan.se/ accesskey=h title="Casper Andersson (Alt + H)">Casper Andersson</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://casan.se/blog title=Blog><span>Blog</span></a></li><li><a href=https://casan.se/docs title=Docs><span>Docs</span></a></li><li><a href=https://casan.se/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://casan.se/about/ title="About Me"><span>About Me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://casan.se/>Home</a>&nbsp;»&nbsp;<a href=https://casan.se/blog/>Blog</a>&nbsp;»&nbsp;<a href=https://casan.se/blog/networks/>Networks</a></div><h1 class=post-title>PTP peer delay measurement</h1><div class=post-meta><span title='2023-10-12 00:00:00 +0000 UTC'>October 12, 2023</span>&nbsp;·&nbsp;5 min</div><ul class=post-tags><li><a href=https://casan.se/tags/networks/>networks</a></li></ul></header><div class=post-content><p>To accurately synchronize the time we need to account for all time lost as the
packet travels. One part of this is the time it takes for packets to travel
across the cable, including egress time after the timestamp is taken, and
ingress time before the timestamp is taken. Though measuring the time it takes
from one device to another is impossible because they will never have the exact
same time, so a timestamp on one side is not guaranteed to match up with a
timestamp on the other side. We have to settle for measuring the roundtrip time
and dividing it by 2, and hope that the delay is symmetric.</p><h2 id=two-step-peer-delay>Two-step peer delay<a hidden class=anchor aria-hidden=true href=#two-step-peer-delay>#</a></h2><p>This is similar to how two-step for synchronization works, we send a packet,
timestamp the egress time, and send a follow-up packet containing the egress
time of the first. Two-step peer delay can be done in two different ways, but
let us explore the concept first.</p><h3 id=two-step-using-full-timestamps>Two-step using full timestamps<a hidden class=anchor aria-hidden=true href=#two-step-using-full-timestamps>#</a></h3><p>Two devices running PTP in peer delay mode will both measure the peer delay
independently. But here I will focus on the transaction from the perspective of
one side. Call one side <em>client</em> and the other side the <em>server</em>. In reality,
both will be both client and server.</p><ol><li>Client sends a peer delay request <code>PDELAY_REQ</code>. It is timestamped <code>t1</code> on
egress and kept by the client.</li><li>Server receives <code>PDELAY_REQ</code> and timestamps it <code>t2</code>.</li><li>Server sends a peer delay response <code>PDELAY_RESP</code> containing <code>t2</code>. It is
timestamped <code>t3</code>.</li><li>Client receives <code>PDELAY_RESP</code> containing <code>t2</code>. It is timestamped <code>t4</code>.</li><li>Server sends a peer delay response follow-up <code>PDELAY_RESP_FUP</code> containing
<code>t3</code>.</li><li>Client receives <code>PDELAY_RESP_FUP</code> containing <code>t3</code>.</li></ol><p>Now the client has all 4 timestamps:</p><ul><li><code>t1</code>: egress time of request</li><li><code>t2</code>: ingress time of request</li><li><code>t3</code>: egress time of response</li><li><code>t4</code>: ingress time of response</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>________t1   t2________
</span></span><span class=line><span class=cl><span class=p>|</span>Client<span class=p>|</span>&gt;-----&gt;<span class=p>|</span>Server<span class=p>|</span>
</span></span><span class=line><span class=cl><span class=p>|</span>______<span class=p>|</span>&lt;-----&lt;<span class=p>|</span>______<span class=p>|</span>
</span></span><span class=line><span class=cl>        t4   t3
</span></span></code></pre></div><p>The formula for calculating the peer delay (meanPathDelay) time looks like this</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=nv>meanPathDelay</span> <span class=o>=</span> <span class=o>((</span>t4-t1<span class=o>)</span> - <span class=o>(</span>t3-t2<span class=o>))</span>/2
</span></span></code></pre></div><p><code>t3-t2</code> represents the time it spent inside the server device, often called
<em>residence time</em>. <code>t4-t1</code> represents the total time the packet was away. The
total time on the wire is then found by subtracting the residence time from the
total time. Dividing by 2 gives the mean delay.</p><h3 id=two-step-using-correctionfield>Two-step using correctionField<a hidden class=anchor aria-hidden=true href=#two-step-using-correctionfield>#</a></h3><p>In this method all the timestamps are still taken the same way as above. But
instead of sending the timestamps back, those fields are simply set to zero, and
the time <code>t3-t2</code> is added to correctionField of the <code>PDELAY_RESP_FUP</code>.</p><p>The full formula is actually slightly longer than what was shown above, to allow
for other forms of compensation</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=nv>meanPathDelay</span> <span class=o>=</span> <span class=o>((</span>t4-t1<span class=o>)</span> - <span class=o>(</span>t3-t2<span class=o>)</span> - pdelay_resp.correction -
</span></span><span class=line><span class=cl>pdelay_resp_fup.correction<span class=o>)</span>/2
</span></span></code></pre></div><p>Here we will now have <code>t2</code> and <code>t3</code> set to zero on the clients side. And that
time instead comes in the <code>pdelay_resp_fup.correction</code>. The end result is the
same. And the server side can choose which method to use since it doesn&rsquo;t matter
to the client.</p><p>CorrectionField contains a number of nanoseconds that should be subtracted by
the receiver. This exists to allow other forms of compensation as well. The
Switchcore or PHY may add compensation for the time it introduces after
timestamping.</p><h2 id=one-step-peer-delay>One-step peer delay<a hidden class=anchor aria-hidden=true href=#one-step-peer-delay>#</a></h2><p>This works similar to one-step synchronization, and uses the correctionField
approach explained above. For this the response ingress timestamp <code>t2</code> is placed
in the <code>reserved2</code> field (4 bytes) before the response is sent. This field is
smaller than the full timestamp, so it only has 2^32 time units to send the
response. Past that it will no longer match to the correct ingress time. If the
time units are nanoseconds then it calculates to ~4.3 seconds, which is plenty
of time to send a response.</p><p>On egress, the timestamp <code>t3</code> is taken, and <code>t3-t2</code> is added to the
correctionField on the fly. Now the residence time is calculated and sent back
to the client, which now uses the following formula</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=nv>meanPathDelay</span> <span class=o>=</span> <span class=o>((</span>t4-t1<span class=o>)</span> - pdelay_resp.correction<span class=o>)</span>/2
</span></span></code></pre></div><p>Note that the full formula from above can still be used, as the unused values
will be 0 (and there will be no follow-up).</p><h2 id=15-step-peer-delay>1.5-step peer delay<a hidden class=anchor aria-hidden=true href=#15-step-peer-delay>#</a></h2><p>This is a combination of two-step and one-step, and can be applied to both sync
and peer delay<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. The idea is that the protocol still behaves the same as
two-step. I.e. it sends follow-up packets. The difference here is that the
timestamp, e.g. <code>t1</code>, is just kept in the timestamping hardware and is not read
out by the CPU. When the matching follow-up (requesting port ID and sequence ID
matches) comes to the hardware the timestamp is filled in. When it goes on the
wire it now looks like a normal two-step.</p><p>The benefit of this is because one-step adds latency to the transmission
as it has to stop, take the timestamp just before transmitting, and then
modify the packet. At speeds of 10Gbit and higher it starts affecting the
transmission speed. The follow-up doesn&rsquo;t have to be modified exactly at
transmission time, it can be prepared ahead of time so it doesn&rsquo;t affect the
latency. By eliminating the readout it minimizes the overhead of sending
packets. Meaning the follow-up packet can be sent immediately after the initial
sync/pdelay_resp.</p><p>1.5-step is not formulated in any standard because it does not affect the
perception. From a protocol point-of-view it is still two-step.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://www.ieee802.org/1/files/public/docs2015/ASRev-pannell-To-1-step-or-not-0315-v1.pdf>https://www.ieee802.org/1/files/public/docs2015/ASRev-pannell-To-1-step-or-not-0315-v1.pdf</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://casan.se/>Casper Andersson</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>