<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Network bridge forwarding and learning | Casper Andersson</title><meta name=keywords content="networks,linux"><meta name=description content="Bridge forwarding of unicast and multicast in software and hardware"><meta name=author content><link rel=canonical href=https://casan.se/blog/networks/network-bridge-forwarding-and-learning/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script src=/js/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=stylesheet href=/css/default.min.css><link rel=icon href=https://casan.se/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://casan.se/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://casan.se/favicon-32x32.png><link rel=apple-touch-icon href=https://casan.se/apple-touch-icon.png><link rel=mask-icon href=https://casan.se/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Network bridge forwarding and learning"><meta property="og:description" content="Bridge forwarding of unicast and multicast in software and hardware"><meta property="og:type" content="article"><meta property="og:url" content="https://casan.se/blog/networks/network-bridge-forwarding-and-learning/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2022-02-18T00:00:00+00:00"><meta property="article:modified_time" content="2022-02-18T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Network bridge forwarding and learning"><meta name=twitter:description content="Bridge forwarding of unicast and multicast in software and hardware"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://casan.se/blog/"},{"@type":"ListItem","position":2,"name":"Networks","item":"https://casan.se/blog/networks/"},{"@type":"ListItem","position":3,"name":"Network bridge forwarding and learning","item":"https://casan.se/blog/networks/network-bridge-forwarding-and-learning/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Network bridge forwarding and learning","name":"Network bridge forwarding and learning","description":"Bridge forwarding of unicast and multicast in software and hardware","keywords":["networks","linux"],"articleBody":"A network switch has multiple ports to send and receive data on. To manage this there is a component called “bridge” inside it. In Linux the bridge is defined as a network interface, but it it can also be offloaded to hardware (at least parts of it). The bridge is responsible for connecting different networks with each other. A packet coming in on one connection has the possibility to go out on any of the other bridged connections.\nForwarding Database (fdb) The Forwarding Database (fdb) stores the information about which bridged connection a data packet should use depending on what the destination is. An fdb entry needs to store the MAC address of the known destination and which connection it should use to reach that. The connection is specified as an interface, e.g., eth3 or vlan3. When a packet arrives at the bridge the MAC address will be inspected and matched to the fdb. If an entry is found it will be forwarded to that interface. If none is found it is treated as unknown and will be flooded to all ports of the same bridge (with the exception for any ports that have flooding disabled).\nHopefully, the flood will result in the destination responding to the packet, sending a reply back to the source. When the reply passes through the bridge it sees which interface it arrived on and will save that in the fdb for next time. Now packets have passed through the bridge from both devices and it has learned which interface each destination is on. Next time they communicate the bridge will find the entries in the fdb and forward the packets correctly.\nShow the contents of the fdb in Linux\nbridge fdb show Ageing To avoid the fdb filling up with old entries a bridge can use ageing. It keeps count of how many seconds has passed since each MAC address sent a packet through the bridge; the counter is reset when a packet from that MAC address enters the bridge. When the age reaches a set threshold it will be removed from the fdb. For example, if a device stops responding to requests it will never refresh the age and the fdb entry will eventually be forgotten since the device is no longer considered part of the network.\nWhat if you want to have a device that only listens to requests? Easy! You can get around the ageing by setting a static fdb entry. These entries will never age, they stay there until you say otherwise.\nAdd a MAC address to be forwarded to the specified interface. To make it static you simply add static at the end\nbridge fdb add dev Multicast database (mdb) The kernel also stores a database of all the multicast groups, which can be seen if you run\nbridge mdb show For multicast it will create a entry when it gets an IGMP Join message. It creates a entry for that group and marks the port that it arrived on. The goal of multicast is to be able to send one message to multiple recipients. Which means that the mdb must store all ports that are in the group, and then remove them when they leave. This is typically stored in a port masks. For a switch with 8 ports, where ports 2 and 4 are in the group, it could look like this 00001010 (represented by the second and fourth bit). This indicates the second and fourth port are in the group. When all ports eventually leave the group it can remove the entry.\nHardware offloading Sometimes you want a bit higher performance. For those times you can use a specialized hardware circuit for network switching. You get less load on your CPU and higher throughput because the packets are switched directly in the hardware and never touches the CPU. One drawback of this is that the hardware only has the features it was built with. If you ever lack some feature you can’t simply write some code for it. But it usually comes with at least some common features, such as its own fdb and mdb that are stored in its own internal memory.\nThe fdb and mdb are stored in a table with fast lookup to quickly switch the packets. The table might look something like this (simplified, it will usually contain more information, e.g., age and if it is static or not)\n------------------------------------------------- | MAC | VLAN | TYPE | DESTINATION | |-----------------------------------------------| | 00:00:00:00:00:01 | 1 | UC | 2 | | 00:00:00:12:ad:fd | 2 | UC | 5 | | 01:00:5e:01:02:03 | 2 | MC | 1 | ------------------------------------------------- The type indicates Unicast or Multicast. The unicast entries points at the port it should send the packet to. Multicast, on the other hand, points to an index in another table. This is where the port mask is stored.\nEntries to this table can be added if the device driver supports it. Then an entry will be added to both software and hardware, since it goes through software first. All multicast addresses are added through software because that is where the IGMP protocol is handled. Though, some entries may exist in hardware only. This happens when the hardware learns unicast entries.\nThese are all things the bridge manages, whether it is a software defined bridge ,like the one in Linux, or if it has been offloaded to a hardware circuit. This has been a little summary of what I have learned at work recently. Thanks for reading!\n","wordCount":"925","inLanguage":"en","datePublished":"2022-02-18T00:00:00Z","dateModified":"2022-02-18T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://casan.se/blog/networks/network-bridge-forwarding-and-learning/"},"publisher":{"@type":"Organization","name":"Casper Andersson","logo":{"@type":"ImageObject","url":"https://casan.se/favicon.svg"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://casan.se/ accesskey=h title="Casper Andersson (Alt + H)">Casper Andersson</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://casan.se/blog title=Blog><span>Blog</span></a></li><li><a href=https://casan.se/docs title=Docs><span>Docs</span></a></li><li><a href=https://casan.se/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://casan.se/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://casan.se/>Home</a>&nbsp;»&nbsp;<a href=https://casan.se/blog/>Blog</a>&nbsp;»&nbsp;<a href=https://casan.se/blog/networks/>Networks</a></div><h1 class=post-title>Network bridge forwarding and learning</h1><div class=post-meta><span title='2022-02-18 00:00:00 +0000 UTC'>February 18, 2022</span>&nbsp;·&nbsp;5 min</div><ul class=post-tags><li><a href=https://casan.se/tags/networks/>networks</a></li><li><a href=https://casan.se/tags/linux/>linux</a></li></ul></header><div class=post-content><p>A network switch has multiple ports to send and receive data on. To manage this
there is a component called &ldquo;bridge&rdquo; inside it. In Linux the bridge is defined
as a network interface, but it it can also be offloaded to hardware (at least
parts of it). The bridge is responsible for connecting different networks with
each other. A packet coming in on one connection has the possibility to go out
on any of the other bridged connections.</p><h2 id=forwarding-database-fdb>Forwarding Database (fdb)<a hidden class=anchor aria-hidden=true href=#forwarding-database-fdb>#</a></h2><p>The Forwarding Database (fdb) stores the information about which bridged
connection a data packet should use depending on what the destination is. An fdb
entry needs to store the MAC address of the known destination and which
connection it should use to reach that. The connection is specified as an
interface, e.g., <code>eth3</code> or <code>vlan3</code>. When a packet arrives at the bridge the MAC
address will be inspected and matched to the fdb. If an entry is found it will
be forwarded to that interface. If none is found it is treated as unknown and
will be flooded to all ports of the same bridge (with the exception for any
ports that have flooding disabled).</p><p>Hopefully, the flood will result in the destination responding to the packet,
sending a reply back to the source. When the reply passes through the bridge it
sees which interface it arrived on and will save that in the fdb for next time.
Now packets have passed through the bridge from both devices and it has learned
which interface each destination is on. Next time they communicate the bridge
will find the entries in the fdb and forward the packets correctly.</p><p>Show the contents of the fdb in Linux</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>bridge fdb show
</span></span></code></pre></div><h2 id=ageing>Ageing<a hidden class=anchor aria-hidden=true href=#ageing>#</a></h2><p>To avoid the fdb filling up with old entries a bridge can use <em>ageing</em>. It
keeps count of how many seconds has passed since each MAC address sent a packet
through the bridge; the counter is reset when a packet from that MAC address
enters the bridge. When the age reaches a set threshold it will be removed from
the fdb. For example, if a device stops responding to requests it will never
refresh the age and the fdb entry will eventually be forgotten since the device
is no longer considered part of the network.</p><p>What if you want to have a device that only listens to requests? Easy! You can
get around the ageing by setting a static fdb entry. These entries will never
age, they stay there until you say otherwise.</p><p>Add a MAC address to be forwarded to the specified interface. To make it static
you simply add <code>static</code> at the end</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>bridge fdb add &lt;MAC&gt; dev &lt;INTERFACE&gt;
</span></span></code></pre></div><h2 id=multicast-database-mdb>Multicast database (mdb)<a hidden class=anchor aria-hidden=true href=#multicast-database-mdb>#</a></h2><p>The kernel also stores a database of all the multicast groups, which can be seen
if you run</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>bridge mdb show
</span></span></code></pre></div><p>For multicast it will create a entry when it gets an IGMP Join message. It
creates a entry for that group and marks the port that it arrived on. The goal
of multicast is to be able to send one message to multiple recipients. Which
means that the mdb must store all ports that are in the group, and then remove
them when they leave. This is typically stored in a port masks. For a switch
with 8 ports, where ports 2 and 4 are in the group, it could look like this
<code>00001010</code> (represented by the second and fourth bit). This indicates the
second and fourth port are in the group. When all ports eventually leave the
group it can remove the entry.</p><h2 id=hardware-offloading>Hardware offloading<a hidden class=anchor aria-hidden=true href=#hardware-offloading>#</a></h2><p>Sometimes you want a bit higher performance. For those times you can use a
specialized hardware circuit for network switching. You get less load on your
CPU and higher throughput because the packets are switched directly in the
hardware and never touches the CPU. One drawback of this is that the hardware
only has the features it was built with. If you ever lack some feature you
can&rsquo;t simply write some code for it. But it usually comes with at least some
common features, such as its own fdb and mdb that are stored in its own
internal memory.</p><p>The fdb and mdb are stored in a table with fast lookup to quickly switch the
packets. The table might look something like this (simplified, it will usually
contain more information, e.g., age and if it is static or not)</p><pre tabindex=0><code class=language-no-hl data-lang=no-hl>-------------------------------------------------
|        MAC        | VLAN | TYPE | DESTINATION |
|-----------------------------------------------|
| 00:00:00:00:00:01 |  1   |  UC  |      2      |
| 00:00:00:12:ad:fd |  2   |  UC  |      5      |
| 01:00:5e:01:02:03 |  2   |  MC  |      1      |
-------------------------------------------------
</code></pre><p>The type indicates Unicast or Multicast. The unicast entries points at the port
it should send the packet to. Multicast, on the other hand, points to an index
in another table. This is where the port mask is stored.</p><p>Entries to this table can be added if the device driver supports it. Then an
entry will be added to both software and hardware, since it goes through
software first. All multicast addresses are added through software because that
is where the IGMP protocol is handled. Though, some entries may exist in
hardware only. This happens when the hardware learns unicast entries.</p><p>These are all things the bridge manages, whether it is a software defined bridge
,like the one in Linux, or if it has been offloaded to a hardware circuit. This
has been a little summary of what I have learned at work recently. Thanks for
reading!</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://casan.se/>Casper Andersson</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>