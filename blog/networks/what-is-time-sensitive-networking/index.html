<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>What is Time-Sensitive Networking? | Casper Andersson</title>
<meta name=keywords content="networks"><meta name=description content="An introduction to Time-Sensitive Networking and some of its techniques"><meta name=author content><link rel=canonical href=https://casan.se/blog/networks/what-is-time-sensitive-networking/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://casan.se/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://casan.se/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://casan.se/favicon-32x32.png><link rel=apple-touch-icon href=https://casan.se/apple-touch-icon.png><link rel=mask-icon href=https://casan.se/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://casan.se/blog/networks/what-is-time-sensitive-networking/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://casan.se/blog/"},{"@type":"ListItem","position":2,"name":"Networks","item":"https://casan.se/blog/networks/"},{"@type":"ListItem","position":3,"name":"What is Time-Sensitive Networking?","item":"https://casan.se/blog/networks/what-is-time-sensitive-networking/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"What is Time-Sensitive Networking?","name":"What is Time-Sensitive Networking?","description":"An introduction to Time-Sensitive Networking and some of its techniques","keywords":["networks"],"articleBody":"Disclaimer! I am in no way an expert at this. I’m learning it as part of a research project at work. This will be the first post in what I hope to be a series of posts on TSN.\nWhat is it? Time-Sensitive Networking (TSN) is a topic in the networking world where there exists data frames that absolutely must arrive within a limited time. It is a fairly new topic and some of the techniques are not completely industry-tested yet. It originates from the sound and video world where they have sound and video that must arrive very quickly. It was originally called Audio Video Bridging (AVB), but was renamed to Time-Sensitive Networking (TSN) in 2012.\nIt could be used at concerts, for example. The sound data must to travel from the microphones to all the speakers, and maybe some cameras to stream to the screen; and it all has to happen very quickly. Humans are very sensitive to delays in sound and video when it doesn’t match up with the reality. To make this even more complex there is often other types of data travelling the network as well. You could make the argument that the sound should use its own cables; however, that is extra maintenance and requires a separate network to run on. It is convenient to be able to use the same network for everything.\nTo work around this they have come up with several techniques for handling Quality of Service (QoS) in networks. I will cover some QoS techniques now, and future posts will go more in-depth on some of them. These are all defined in IEEE standards.\nTSN techniques Strict Priority (802.1Q) The most basic form of QoS. This, as well as several of the below techniques, are based on the concept of multiple egress queues. Usually 8 of them. With 8 queues you can do a 1-to-1 mapping from the Priority Code Point (PCP) in the VLAN tag. There are some techniques to set the priority from software (see man mqprio). In Linux, this is the skb-\u003epriority field. But when you use QoS you usually want the frames to only pass through the hardware. There is currently only support in the Linux kernel to set this for this for the DSCP field (man dcb-app), but hopefully we can get a proper way to set this for PCP as well. It is already supported by a lot of the hardware. There are other ways to do this in the hardware as well, but not all are ideal.\nAs for the algorithm itself, it is very simple. It transmits frames in order of priority. When it starts transmitting a frames it picks from the highest priority queue that is not empty. A lower priority queue will only transmit if all higher priority queues are empty. Below is an illustration of 3 transmit queues with frames A-H, where frames in queue 2 would have the highest priority.\nQueue ---------------------- 0 -\u003e [H] [G] [F] [D] -\u003e ---------------------- 1 -\u003e [E] [C] -\u003e ---------------------- 2 -\u003e [B] [A] -\u003e ---------------------- Time-Aware Shaper (802.1Qbv) This extends the Strict Priority algorithm by adding a time aspect to it and splitting the time into several slots where different priorities are allowed to send in each slot. For example, it could have 2 slots, one where only priority 7 (highest) is allowed to send, and another where priority 0-6 are allowed to send. The time slots can be of different length. For the second slot there are 7 different priorities that can send, so between those it applies Strict Priority.\nTime-Aware Shapers can run in software, but the benefit it gives is completely lost. To be at all useful it needs to be offloaded to hardware, which also requires a PTP hardware clock. On top of the clock itself it should also be time synced to all other switches in the network. Otherwise, there is also very little point in using it. If all switches are synced it will result in the same priorities all being open at once in the network; ideally letting the frames flow all the way to their destination without being interrupted by other traffic. To put it simply, it can reserve bandwidth for the different priorities and giving the network a deterministic behavior (at least for high priorities), but of course this assumes you aren’t overloading the network itself. If you try to overload the link it will obviously drop and delay frames.\n[Read more…]({% post_url networks/2022-08-25-time-aware-shaper %})\nCredit-Based Shaper (802.1Qav) The original TSN technique that was invented for the purpose of audio and video. It reduces the congestion in the network by evening out bursts. It is a form of fair queueing. Like Strict Priority, this also uses multiple egress queues. Each queue holds a credit score that goes up when a queue is not transmitting, and down when it transmits. When the credit score goes negative it is not allowed to transmit. By evening out the traffic to get rid of bursts the data can flow more freely in the network. This is especially useful when there are many devices in the network that may send bursts. If all send a burst at once it can result in the queues filling up where the bursts meet.\nFrame Preemption (802.1Qbu) Frame preemption is the only of the priority-based TSN techniques that requires both ends of a link to support its protocol. The ones above can all operate on a single switch, though ideally used in a network were all are running the same technique. It also requires hardware support. With frame preemption both sides work together to provide faster delivery speed. To begin, we first have to define which priorities (queues) are to be considered preemptible. This is done independently on each switch.\nIf a preemptible frame is currently being transmitted and an express (non-preemptible) frame arrives to the queue it will almost immediately stop the preemptible frame (it preempts it). To not have wasted all the work already done sending the frame it appends a CRC32 checksum to the end of the partial frame, as well as inverts the last 16 bits of the CRC value to distinguish a partial frame from a regular frame. When that is done it can start sending the express frame. The partial frame is stored in a separate buffer on the other end and waits for the other half of its frame to arrive. The other half is sent when no more express traffic is available to send.\nFrame Replication and Elimination for Reliability (802.1CB) The final technique for this post is the only one not dependent on multiple queues and priorities. Rather than providing fast delivery it is a form of redundancy. The idea is that it duplicates frames and sends them different paths in a ring or otherwise redundant topology. In the case of one switch failing it doesn’t even have to wait for the switches to learn the new path. The frames are already on their way the other path as well. To not get duplicate frames at the destination it eliminates any duplicates where they meet again, ideally as close to the destination as possible; possibly even at the end device. Same as frame preemption, this requires the mergeing device to also support the protocol. The intermediary switches do not need to support it, they just need to forward the frame.\nKeeping track of duplicates in the merging device is done with the help of a sequence number in the duplicated frames. This is called the R-tag and it has a 16-bits field to store the sequence number. The R-tag is then removed when a frame arrives at the merging device, and any following frames with the same sequence numbers are discarded.\nIn the case of multiple senders to the same merging device it can employ a stream identification function to identify which data stream a frame belongs to. Two frames can have the same sequence number but belong to different streams, and we don’t want one of those to be discarded because they are not the same frame.\nTSN today TSN techniques are still considered fairly new and is not entirely industry-proven. It is starting to appear more and more in factories with the advent of Industry 4.0 and companies wanting to make their factories smart and more modern. By using a single network for everything you simplify connections and reduce the amount of cables. The time-sensitive aspect comes from, for example, control systems that need to send instructions instantly other machines. It has also gained traction in the automobile industry for use inside cars to connect various smart devices such as cameras, sensors, control devices, etc., with the main computers.\n","wordCount":"1459","inLanguage":"en","datePublished":"2022-06-07T00:00:00Z","dateModified":"2022-06-07T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://casan.se/blog/networks/what-is-time-sensitive-networking/"},"publisher":{"@type":"Organization","name":"Casper Andersson","logo":{"@type":"ImageObject","url":"https://casan.se/favicon.svg"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://casan.se/ accesskey=h title="Casper Andersson (Alt + H)">Casper Andersson</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://casan.se/blog title=Blog><span>Blog</span></a></li><li><a href=https://casan.se/docs title=Docs><span>Docs</span></a></li><li><a href=https://casan.se/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://casan.se/about/ title="About Me"><span>About Me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://casan.se/>Home</a>&nbsp;»&nbsp;<a href=https://casan.se/blog/>Blog</a>&nbsp;»&nbsp;<a href=https://casan.se/blog/networks/>Networks</a></div><h1 class=post-title>What is Time-Sensitive Networking?</h1><div class=post-meta><span title='2022-06-07 00:00:00 +0000 UTC'>June 7, 2022</span>&nbsp;·&nbsp;7 min</div><ul class=post-tags><li><a href=https://casan.se/tags/networks/>Networks</a></li></ul></header><div class=post-content><p><strong>Disclaimer!</strong>
I am in no way an expert at this. I&rsquo;m learning it as part of a
research project at work. This will be the first post in what I hope to be a
series of posts on TSN.</p><h2 id=what-is-it>What is it?<a hidden class=anchor aria-hidden=true href=#what-is-it>#</a></h2><p>Time-Sensitive Networking (TSN) is a topic in the networking world where there
exists data frames that absolutely must arrive within a limited time. It is a
fairly new topic and some of the techniques are not completely industry-tested
yet. It originates from the sound and video world where they have sound and
video that must arrive very quickly. It was originally called Audio Video
Bridging (AVB), but was renamed to Time-Sensitive Networking (TSN) in 2012.</p><p>It could be used at concerts, for example. The sound data must to travel from
the microphones to all the speakers, and maybe some cameras to stream to the
screen; and it all has to happen very quickly. Humans are very sensitive to
delays in sound and video when it doesn&rsquo;t match up with the reality. To make
this even more complex there is often other types of data travelling the network
as well. You could make the argument that the sound should use its own cables;
however, that is extra maintenance and requires a separate network to run on. It
is convenient to be able to use the same network for everything.</p><p>To work around this they have come up with several techniques for handling
Quality of Service (QoS) in networks. I will cover some QoS techniques now, and
future posts will go more in-depth on some of them. These are all defined in
IEEE standards.</p><h2 id=tsn-techniques>TSN techniques<a hidden class=anchor aria-hidden=true href=#tsn-techniques>#</a></h2><h3 id=strict-priority-8021q>Strict Priority (802.1Q)<a hidden class=anchor aria-hidden=true href=#strict-priority-8021q>#</a></h3><p>The most basic form of QoS. This, as well as several of the below techniques, are
based on the concept of multiple egress queues. Usually 8 of them. With 8 queues
you can do a 1-to-1 mapping from the Priority Code Point (PCP) in the VLAN tag.
There are some techniques to set the priority from software (see <code>man mqprio</code>).
In Linux, this is the <code>skb->priority</code> field. But when you use QoS you usually
want the frames to only pass through the hardware. There is currently only
support in the Linux kernel to set this for this for the DSCP field (<code>man dcb-app</code>), but hopefully we can get a proper way to set this for PCP as well. It
is already supported by a lot of the hardware. There are other ways to do this
in the hardware as well, but not all are ideal.</p><p>As for the algorithm itself, it is very simple. It transmits frames in order
of priority. When it starts transmitting a frames it picks from the highest
priority queue that is not empty. A lower priority queue will only transmit if
all higher priority queues are empty. Below is an illustration of 3 transmit
queues with frames A-H, where frames in queue 2 would have the highest
priority.</p><pre tabindex=0><code class=language-no-hl data-lang=no-hl>Queue
    ----------------------
  0 -&gt;     [H] [G] [F] [D] -&gt;
    ----------------------
  1 -&gt;             [E] [C] -&gt;
    ----------------------
  2 -&gt;             [B] [A] -&gt;
    ----------------------
</code></pre><h3 id=time-aware-shaper-8021qbv>Time-Aware Shaper (802.1Qbv)<a hidden class=anchor aria-hidden=true href=#time-aware-shaper-8021qbv>#</a></h3><p>This extends the Strict Priority algorithm by adding a time aspect to it and
splitting the time into several slots where different priorities are allowed to
send in each slot. For example, it could have 2 slots, one where only priority 7
(highest) is allowed to send, and another where priority 0-6 are allowed to
send. The time slots can be of different length. For the second slot there are 7
different priorities that can send, so between those it applies Strict Priority.</p><p>Time-Aware Shapers can run in software, but the benefit it gives is completely
lost. To be at all useful it needs to be offloaded to hardware, which also
requires a PTP hardware clock. On top of the clock itself it should also be time
synced to all other switches in the network. Otherwise, there is also very
little point in using it. If all switches are synced it will result in the same
priorities all being open at once in the network; ideally letting the frames
flow all the way to their destination without being interrupted by other
traffic. To put it simply, it can reserve bandwidth for the different
priorities and giving the network a deterministic behavior (at least for high
priorities), but of course this assumes you aren&rsquo;t overloading the network
itself. If you try to overload the link it will obviously drop and delay frames.</p><p>[Read more&mldr;]({% post_url networks/2022-08-25-time-aware-shaper %})</p><h3 id=credit-based-shaper-8021qav>Credit-Based Shaper (802.1Qav)<a hidden class=anchor aria-hidden=true href=#credit-based-shaper-8021qav>#</a></h3><p>The original TSN technique that was invented for the purpose of audio and video.
It reduces the congestion in the network by evening out bursts. It is a form of
fair queueing. Like Strict Priority, this also uses multiple egress queues. Each
queue holds a credit score that goes up when a queue is not transmitting, and
down when it transmits. When the credit score goes negative it is not allowed to
transmit. By evening out the traffic to get rid of bursts the data can flow more
freely in the network. This is especially useful when there are many devices in
the network that may send bursts. If all send a burst at once it can result in
the queues filling up where the bursts meet.</p><h3 id=frame-preemption-8021qbu>Frame Preemption (802.1Qbu)<a hidden class=anchor aria-hidden=true href=#frame-preemption-8021qbu>#</a></h3><p>Frame preemption is the only of the priority-based TSN techniques that
<strong>requires</strong> both ends of a link to support its protocol. The ones above can all
operate on a single switch, though ideally used in a network were all are
running the same technique. It also requires hardware support. With frame
preemption both sides work together to provide faster delivery speed. To begin,
we first have to define which priorities (queues) are to be considered
preemptible. This is done independently on each switch.</p><p>If a preemptible frame is currently being transmitted and an express
(non-preemptible) frame arrives to the queue it will almost immediately stop the
preemptible frame (it preempts it). To not have wasted all the work already
done sending the frame it appends a CRC32 checksum to the end of the partial
frame, as well as inverts the last 16 bits of the CRC value to distinguish a
partial frame from a regular frame. When that is done it can start sending the
express frame. The partial frame is stored in a separate buffer on the other
end and waits for the other half of its frame to arrive. The other half is sent
when no more express traffic is available to send.</p><h3 id=frame-replication-and-elimination-for-reliability-8021cb>Frame Replication and Elimination for Reliability (802.1CB)<a hidden class=anchor aria-hidden=true href=#frame-replication-and-elimination-for-reliability-8021cb>#</a></h3><p>The final technique for this post is the only one not dependent on multiple
queues and priorities. Rather than providing fast delivery it is a form of
redundancy. The idea is that it duplicates frames and sends them different
paths in a ring or otherwise redundant topology. In the case of one switch
failing it doesn&rsquo;t even have to wait for the switches to learn the new path. The
frames are already on their way the other path as well. To not get duplicate
frames at the destination it eliminates any duplicates where they meet again,
ideally as close to the destination as possible; possibly even at the end
device. Same as frame preemption, this requires the mergeing device to also
support the protocol. The intermediary switches do not need to support it, they
just need to forward the frame.</p><p>Keeping track of duplicates in the merging device is done with the help of a
sequence number in the duplicated frames. This is called the R-tag and it has a
16-bits field to store the sequence number. The R-tag is then removed when a
frame arrives at the merging device, and any following frames with the same
sequence numbers are discarded.</p><p>In the case of multiple senders to the same merging device it can employ a
<em>stream identification function</em> to identify which data stream a frame belongs
to. Two frames can have the same sequence number but belong to different
streams, and we don&rsquo;t want one of those to be discarded because they are not the
same frame.</p><h2 id=tsn-today>TSN today<a hidden class=anchor aria-hidden=true href=#tsn-today>#</a></h2><p>TSN techniques are still considered fairly new and is not entirely
industry-proven. It is starting to appear more and more in factories with the
advent of Industry 4.0 and companies wanting to make their factories smart and
more modern. By using a single network for everything you simplify connections
and reduce the amount of cables. The time-sensitive aspect comes from, for
example, control systems that need to send instructions instantly other
machines. It has also gained traction in the automobile industry for use inside
cars to connect various smart devices such as cameras, sensors, control
devices, etc., with the main computers.</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://casan.se/>Casper Andersson</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>