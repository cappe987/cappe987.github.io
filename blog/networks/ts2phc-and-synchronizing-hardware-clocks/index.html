<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ts2phc and synchronizing hardware clocks | Casper Andersson</title>
<meta name=keywords content="networks,linux"><meta name=description content="How to use ts2phc to synchronize clocks"><meta name=author content><link rel=canonical href=https://casan.se/blog/networks/ts2phc-and-synchronizing-hardware-clocks/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script src=/js/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=stylesheet href=/css/default.min.css><link rel=icon href=https://casan.se/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://casan.se/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://casan.se/favicon-32x32.png><link rel=apple-touch-icon href=https://casan.se/apple-touch-icon.png><link rel=mask-icon href=https://casan.se/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="ts2phc and synchronizing hardware clocks"><meta property="og:description" content="How to use ts2phc to synchronize clocks"><meta property="og:type" content="article"><meta property="og:url" content="https://casan.se/blog/networks/ts2phc-and-synchronizing-hardware-clocks/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2024-01-06T00:00:00+00:00"><meta property="article:modified_time" content="2024-01-06T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="ts2phc and synchronizing hardware clocks"><meta name=twitter:description content="How to use ts2phc to synchronize clocks"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://casan.se/blog/"},{"@type":"ListItem","position":2,"name":"Networks","item":"https://casan.se/blog/networks/"},{"@type":"ListItem","position":3,"name":"ts2phc and synchronizing hardware clocks","item":"https://casan.se/blog/networks/ts2phc-and-synchronizing-hardware-clocks/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ts2phc and synchronizing hardware clocks","name":"ts2phc and synchronizing hardware clocks","description":"How to use ts2phc to synchronize clocks","keywords":["networks","linux"],"articleBody":"The Precision Time Protocol, PTP, is used for synchronizing time across the network. But what if the clocks I want to synchronize are all internal?\nIn previous posts, I have explained parts of PTP and how that is used to synchronize devices in a network. PTP is often done with the ptp4l daemon from the Linuxptp project, and it is overall a well-explained protocol across the web. There are many resources. The project also provides a couple of other tools, one of which is ts2phc, which has way less documentation about it online. This post will focus on what it does and why it’s needed.\nWhy is it needed? Some network switches will only have a single PHC that is shared across all ports. In this case, no synchronization is needed. If instead the PHC and timestamping are located in the PHY there is one PHC per port (or 2/4 ports for dual/quad PHY). When running PTP across multiple PHYs their time needs to be synchronized. For a Transparent Clock, they will never be adjusted by PTP, but they must still have the same time. Running ts2phc on them will ensure that they always stay within a few nanoseconds of each other. For a Boundary Clock, the time of one PHY will constantly be adjusted by PTP (the port towards the PTP Grandmaster), while the other ports act as masters for downstream clocks. Internally the PHY towards the Grandmaster will act as a master for the other PHY clocks to make sure that the time transmitted downstream is in sync with upstream.\nFor Transparent Clocks, a single alignment pulse can sometimes be used to make all clocks start their time counting at the same time, and then never need to be synchronized again. But this depends on the PHYs and there is no official support for this in Linux and requires all PHYs to run on the same oscillator.\nHow synchronization works Internal clocks do not have any network connections between them, so reusing the PTP daemon isn’t an option. The naive approach would be to read out the current time from each clock, compare them, and adjust the clocks accordingly. This is what the Linuxptp application phc2sys does. But as the name suggests the purpose of it is to synchronize the time of a Physical Hardware Clock (PHC) to the system. Or vice versa if the system acts as the Grandmaster clock of the network. As for synchronizing two PHCs this simply isn’t good enough. The precision will be unacceptable compared to the precision you can reach with PTP; a Boundary/Transparent clock that does this will probably introduce more inaccuracy than if it just forwarded the PTP packet in hardware.\nTo the rescue comes the Linuxptp application ts2phc. This application needs some specialized hardware design to work. The issue with phc2sys is that comparing timestamps that are taken at different times inherently gives inaccurate results. For perfect synchronization, the timestamps must be taken as close together as possible. The solution for this is a signal line in the PCB. Each PHC is set up by ts2phc to take a timestamp when a pulse is received on that line. A pulse is then triggered and timestamps are read out from all PHC, compared, and adjusted.\nOn the hardware, the different PHCs need to be connected on a single line, as shown below. One of the clocks will be configured to send out the pulse, while the other two are configured to timestamp the pulse. The line may be subject to some propagation delay on large boards. Online resources suggest 1 nanosecond per 15cm1. Which for normal PTP operation probably isn’t enough to worry about.\n+-------+-------+ | | | +----+ +----+ +----+ |PHC1| |PHC2| |PHC3| +----+ +----+ +----+ Linux kernel API The Linux kernel exposes two APIs for this purpose. EXTTS (EXTernal TimeStamp) configures the PHC to timestamp on a signal on a specific hardware pin. PEROUT (PERiodic OUTput) configures a PPS (Pulse-Per-Second) signal on one of the PHCs that will trigger every time the PHC is at a whole second time.\nThe PHC dedicated as master will be configured with PEROUT, while the rest are EXTTS. Because the PPS is always triggered at a whole second it can find the timestamp of the master PHC by reading the current time and rounding down, assuming we do it within a second (i.e. before the next signal). In theory, however, there is no requirement for the pulse to happen every second. It’s fully possible to have something external trigger a pulse to all PHC, including the master (the master also needs to be configured for EXTTS in this case). It’s also possible for the PHC sending PPS to be treated as slave and be adjusted. What is important is that there is a timestamp from every clock that we can compare.\nCombining it with PTP For every setup there needs to be one master PHC and the rest are slaves. The slaves are compared to and adjusted to match the time of the master. ts2phc expects one PHC to be configured as master. But there are cases when a dynamic setup is required, e.g. when running a PTP Boundary Clock across the PHCs. The master PHC must always be the one acting as PTP slave, the one in the direction of the Grandmaster, as this is the one being adjusted from an external source. This time must be distributed to all other PHCs for the time to continue being accurate downstream. If the Grandmaster changes position and another PHC is now being adjusted by PTP then ts2phc also requires changing master. To do this the command line argument ts2phc -a can be used to listen to port state events from ptp4l. Now ts2phc will always match its master to the PTP slave port.\nIt may also be useful to set the option ts2phc --step_threshold=0.0001 to allow stepping the clocks. Otherwise, the clocks can end up stabilizing internally before a Grandmaster is found, and will then take a long time to converge.\nhttps://madpcb.com/glossary/propagation-delay ↩︎\n","wordCount":"1010","inLanguage":"en","datePublished":"2024-01-06T00:00:00Z","dateModified":"2024-01-06T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://casan.se/blog/networks/ts2phc-and-synchronizing-hardware-clocks/"},"publisher":{"@type":"Organization","name":"Casper Andersson","logo":{"@type":"ImageObject","url":"https://casan.se/favicon.svg"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://casan.se/ accesskey=h title="Casper Andersson (Alt + H)">Casper Andersson</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://casan.se/blog title=Blog><span>Blog</span></a></li><li><a href=https://casan.se/docs title=Docs><span>Docs</span></a></li><li><a href=https://casan.se/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://casan.se/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://casan.se/>Home</a>&nbsp;»&nbsp;<a href=https://casan.se/blog/>Blog</a>&nbsp;»&nbsp;<a href=https://casan.se/blog/networks/>Networks</a></div><h1 class=post-title>ts2phc and synchronizing hardware clocks</h1><div class=post-meta><span title='2024-01-06 00:00:00 +0000 UTC'>January 6, 2024</span>&nbsp;·&nbsp;5 min</div><ul class=post-tags><li><a href=https://casan.se/tags/networks/>networks</a></li><li><a href=https://casan.se/tags/linux/>linux</a></li></ul></header><div class=post-content><p>The Precision Time Protocol, PTP, is used for synchronizing time across the
network. But what if the clocks I want to synchronize are all internal?</p><p>In previous posts, I have explained parts of PTP and how that is used to
synchronize devices in a network. PTP is often done with the <code>ptp4l</code> daemon from
the Linuxptp project, and it is overall a well-explained protocol across the
web. There are many resources. The project also provides a couple of other
tools, one of which is <code>ts2phc</code>, which has way less documentation about it
online. This post will focus on what it does and why it&rsquo;s needed.</p><h2 id=why-is-it-needed>Why is it needed?<a hidden class=anchor aria-hidden=true href=#why-is-it-needed>#</a></h2><p>Some network switches will only have a single PHC that is shared across all
ports. In this case, no synchronization is needed. If instead the PHC and
timestamping are located in the PHY there is one PHC per port (or 2/4 ports for
dual/quad PHY). When running PTP across multiple PHYs their time needs to be
synchronized. For a Transparent Clock, they will never be adjusted by PTP, but
they must still have the same time. Running <code>ts2phc</code> on them will ensure that
they always stay within a few nanoseconds of each other. For a Boundary Clock,
the time of one PHY will constantly be adjusted by PTP (the port towards the PTP
Grandmaster), while the other ports act as masters for downstream clocks.
Internally the PHY towards the Grandmaster will act as a master for the other
PHY clocks to make sure that the time transmitted downstream is in sync with
upstream.</p><p>For Transparent Clocks, a single alignment pulse can sometimes be used to make
all clocks start their time counting at the same time, and then never need to be
synchronized again. But this depends on the PHYs and there is no official
support for this in Linux and requires all PHYs to run on the same oscillator.</p><h2 id=how-synchronization-works>How synchronization works<a hidden class=anchor aria-hidden=true href=#how-synchronization-works>#</a></h2><p>Internal clocks do not have any network connections between them, so reusing the
PTP daemon isn&rsquo;t an option. The naive approach would be to read out the current
time from each clock, compare them, and adjust the clocks accordingly. This is
what the Linuxptp application <code>phc2sys</code> does. But as the name suggests the
purpose of it is to synchronize the time of a Physical Hardware Clock (PHC) to
the system. Or vice versa if the system acts as the Grandmaster clock of the
network. As for synchronizing two PHCs this simply isn&rsquo;t good enough. The
precision will be unacceptable compared to the precision you can reach with PTP;
a Boundary/Transparent clock that does this will probably introduce more
inaccuracy than if it just forwarded the PTP packet in hardware.</p><p>To the rescue comes the Linuxptp application <code>ts2phc</code>. This application needs
some specialized hardware design to work. The issue with phc2sys is that
comparing timestamps that are taken at different times inherently gives
inaccurate results. For perfect synchronization, the timestamps must be taken as
close together as possible. The solution for this is a signal line in the PCB.
Each PHC is set up by <code>ts2phc</code> to take a timestamp when a pulse is received on
that line. A pulse is then triggered and timestamps are read out from all PHC,
compared, and adjusted.</p><p>On the hardware, the different PHCs need to be connected on a single line, as
shown below. One of the clocks will be configured to send out the pulse, while
the other two are configured to timestamp the pulse. The line may be subject to
some propagation delay on large boards. Online resources suggest 1 nanosecond
per 15cm<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. Which for normal PTP operation probably isn&rsquo;t enough to worry
about.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>  +-------+-------+
</span></span><span class=line><span class=cl>  |       |       |
</span></span><span class=line><span class=cl>+----+  +----+  +----+
</span></span><span class=line><span class=cl>|PHC1|  |PHC2|  |PHC3|
</span></span><span class=line><span class=cl>+----+  +----+  +----+
</span></span></code></pre></div><h2 id=linux-kernel-api>Linux kernel API<a hidden class=anchor aria-hidden=true href=#linux-kernel-api>#</a></h2><p>The Linux kernel exposes two APIs for this purpose. EXTTS (EXTernal TimeStamp)
configures the PHC to timestamp on a signal on a specific hardware pin. PEROUT
(PERiodic OUTput) configures a PPS (Pulse-Per-Second) signal on one of the PHCs
that will trigger every time the PHC is at a whole second time.</p><p>The PHC dedicated as master will be configured with PEROUT, while the rest are
EXTTS. Because the PPS is always triggered at a whole second it can find the
timestamp of the master PHC by reading the current time and rounding down,
assuming we do it within a second (i.e. before the next signal). In theory,
however, there is no requirement for the pulse to happen every second. It&rsquo;s
fully possible to have something external trigger a pulse to all PHC, including
the master (the master also needs to be configured for EXTTS in this case). It&rsquo;s
also possible for the PHC sending PPS to be treated as slave and be adjusted.
What is important is that there is a timestamp from every clock that we can
compare.</p><h2 id=combining-it-with-ptp>Combining it with PTP<a hidden class=anchor aria-hidden=true href=#combining-it-with-ptp>#</a></h2><p>For every setup there needs to be one master PHC and the rest are slaves. The
slaves are compared to and adjusted to match the time of the master. <code>ts2phc</code>
expects one PHC to be configured as master. But there are cases when a dynamic
setup is required, e.g. when running a PTP Boundary Clock across the PHCs. The
master PHC must always be the one acting as PTP slave, the one in the direction
of the Grandmaster, as this is the one being adjusted from an external source.
This time must be distributed to all other PHCs for the time to continue being
accurate downstream. If the Grandmaster changes position and another PHC is now
being adjusted by PTP then <code>ts2phc</code> also requires changing master. To do this the
command line argument <code>ts2phc -a</code> can be used to listen to port state events
from <code>ptp4l</code>. Now ts2phc will always match its master to the PTP slave port.</p><p>It may also be useful to set the option <code>ts2phc --step_threshold=0.0001</code> to
allow stepping the clocks. Otherwise, the clocks can end up stabilizing
internally before a Grandmaster is found, and will then take a long time to
converge.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://madpcb.com/glossary/propagation-delay>https://madpcb.com/glossary/propagation-delay</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://casan.se/>Casper Andersson</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>