<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>PTP and timestamping methods | Casper Andersson</title>
<meta name=keywords content="networks"><meta name=description content="A maybe not so gentle introduction to the Precision Time Protocol"><meta name=author content><link rel=canonical href=https://casan.se/blog/networks/ptp-and-timestamping-methods/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script src=/js/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=stylesheet href=/css/default.min.css><link rel=icon href=https://casan.se/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://casan.se/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://casan.se/favicon-32x32.png><link rel=apple-touch-icon href=https://casan.se/apple-touch-icon.png><link rel=mask-icon href=https://casan.se/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="PTP and timestamping methods"><meta property="og:description" content="A maybe not so gentle introduction to the Precision Time Protocol"><meta property="og:type" content="article"><meta property="og:url" content="https://casan.se/blog/networks/ptp-and-timestamping-methods/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2023-04-05T00:00:00+00:00"><meta property="article:modified_time" content="2023-04-05T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="PTP and timestamping methods"><meta name=twitter:description content="A maybe not so gentle introduction to the Precision Time Protocol"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://casan.se/blog/"},{"@type":"ListItem","position":2,"name":"Networks","item":"https://casan.se/blog/networks/"},{"@type":"ListItem","position":3,"name":"PTP and timestamping methods","item":"https://casan.se/blog/networks/ptp-and-timestamping-methods/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"PTP and timestamping methods","name":"PTP and timestamping methods","description":"A maybe not so gentle introduction to the Precision Time Protocol","keywords":["networks"],"articleBody":" Computers in networks traditionally don’t have any knowledge of when other computers can/will transmit data. Dozens of devices transmitting data whenever they want will inevitably lead to collisions and congestions at one point or another, which in turn leads to packets not arriving as soon as they should. Packets arriving later than intended may affect what the receiver should do with it. Data can expire. If the timeframe for its usefulness has passed then the receiver must know this, or else it may perform actions based on old information. There exist techniques to improve predictability in networks, but this post will focus on a common understanding of time.\nClock synchronization across the internet typically uses software timestamping to make sure your computer clock shows the same as the rest of the world (disregarding timezones). In a best-case scenario software timestamping can reach a precision of under a millisecond, but also a worst-case of hundreds of milliseconds. To the human eye looking at a clock, this appears good enough, but machines may require much higher precision in certain use cases.\nA new level of precision The IEEE 1588 standard defines the Precision Time Protocol, also known as PTP. This protocol allows synchronization of hardware clocks down to nanosecond precision in a local network. Devices achieve this by timestamping packets they send and receive and comparing the time, and estimating and adjusting according to the cable delay. But using software timestamping still limits the precision due to processor scheduling and other network traffic that creates variation in the actual transmission time.\nTo solve this there exist ethernet ports with support for hardware timestamping. PTP requires a device to know both the transmission and reception time. Sending over only the current time from the master clock would make the slave show an earlier time than the master since the master will have moved forward by the time the slave has received and adjusted the clock. The participating devices also need to determine how long delay the wire itself incurs. A long cable, or even a time-unaware switch, can add noticeable delays (noticeable from a nanosecond perspective).\nGood! Now we have established the requirement! But how does this help us?\nThe synchronization process of a slave clock consists of two steps:\nGetting the current time from a master clock Finding the cable delay and adding that to the time received from the master Step (1) involves the master sending the current time, taken as close to the wire as possible, in a Sync packet to the slave. PTP defines two methods for doing this: one-step and two-step. This is explained in more detail later. The slave can now update its clock to the provided timestamp. Upon reception, the packet gets timestamped again. Now the slave has receive_time - transmit_time = offset_from_master. The slave can now adjust its clock to the calculated offset. Though it has not yet compensated for the cable delay. If PTP only ever did step (1) the slave would always stay behind the master by cable_delay time. Devices would then end up further behind the further they are from the master, and each intermediate switch would add more to that.\nFor step (2) the slave sends a Delay_Req (delay request) to the master and records the transmission time (t1) for itself to use later. The master timestamps the reception time (t2) of the message and sends that back in a Delay_Resp (delay response) to the slave.\nBecause t1 was already cable_delay time behind the master clock, due to the cable delay on the previous Sync packet, the difference between t1 and t2 will now be cable_delay * 2. This means the slave clock should add (t2-t1)/2 to its clock. Now the master and slave clocks have successfully synchronized. The process will then repeat at regular intervals to make sure everything stays synchronized.\nSoftware daemon The hardware only needs to implement the timestamping functionality to support PTP. But managing these different types of packets, as well as deciding who should be master and who should be slave, requires software. Usually in the form of a daemon. Richard Cochran maintains the most popular implementation of PTP in the project linuxptp.\nOne-step vs two-step When the hardware receives a packet it will save the timestamp in packet metadata that can then be fetched by the receiving application. Simple enough!\nThe transmission poses more of a challenge since metadata can’t be included on the wire. As mentioned earlier, there exist two methods for handling this. The simplest one involves sending a packet, taking the timestamp from when it was sent, and then sending a Follow_Up packet that includes the transmission time of the first packet. This is called two-step timestamping.\nThe other alternative, one-step timestamping, requires hardware that can detect and modify the right fields in the PTP packets as they go out on the wire. That way the packet contains the data.\nThe following illustration shows the slave clock synchronizing to the master clock using two-step timestamping. The cable has a delay of 1 time unit. Described from the point of the master clock’s time:\nMaster Slave ┌───────────┐ │ │ 50─┼──────┐ ├─20 │ │ │ 51─┼────┐ └───►├─21 │ │ │ 52─┤ └─────►├─22-\u003e51 │ │ 53─┤ ┌─────┼─52 │ │ │ 54─┤◄────┘ ├─53 │ │ 55─┼─────┐ ├─54 │ │ │ 56─┤ └────►├─55-\u003e56 │ │ 57─┤ ├─57 └───────────┘ Master sends Sync packet and timestamps it (50). Slave receives Sync and timestamps it (21). Master sends Follow_Up containing the transmission time of Sync. Slave receives Follow_Up and calculates the difference between Sync transmission and reception. 50-21=29. Slave updates its clock by adjusting it +29. 22+29=51. Slave sends a Delay_Req and timestamps it (52). Master receives Delay_Req and timestamps it (54). Master sends back the Delay_Req timestamp in a Delay_Resp packet. Slave receives Delay_Resp. It now has the timestamps 52 and 54, which represents the cable delay multiplied by 2. Half comes from the packet delay request. And the other half comes from the earlier Sync packet where the slave knowingly set its time to cable_delay behind the master since it didn’t know the delay. The slave adjusts its time by (54-52)/2=1 and moves it 1 unit forward. The clocks are now synced. Using one-step works the same, with the only difference that the master does not need to send a Follow_Up packet.\nTwo-step only requires the networking hardware to be capable of timestamping packets. The timestamping happens either in the MAC hardware or the PHY hardware. The PHY will provide better accuracy since it allows timestamping to be the last action before the packet goes on the wire. Performing timestamping in the MAC can give slightly higher variation in accuracy, but still good enough for many use cases.\nThe following illustration shows an example layout of how a MAC and PHY would be attached in switching hardware. The PHY attaches directly to the cable.\n┌───┐ │CPU│ └─┬─┘ │ ┌─┴─┐ ┌───┤MAC├───┐ │ └─┬─┘ │ │ │ │ ┌─┴─┐ ┌─┴─┐ ┌─┴─┐ │PHY│ │PHY│ │PHY│ └▲─▼┘ └▲─▼┘ └▲─▼┘ For one-step, the hardware also needs the functionality to modify the packet, and that includes understanding the PTP packet layout. Using one-step results in fewer packets to handle and slightly faster convergence (time for all clocks in the network to get accurately synced) since it never has to wait for a second packet. Though with the introduction of the standard 802.1AS, it has been shown that two-step can perform just as well, and the extra traffic on the network becomes insignificant at the network speeds of today.\nSo why doesn’t everyone use one-step? At the surface, it looks good, but looking deeper one-step has some drawbacks. When reaching speeds of 10Gbit and higher it will incur penalties for the time spent taking the timestamp and modifying the packet1. The network transmits fast enough that it takes longer to add the time than the actual transmission. This means that the hardware can’t work at full wire speed while timestamping just before transmitting. To get around this the hardware could try to predict the transmission time and prepare the packet ahead of time. But that too has its issues as preparing ahead of time adds latency to all outgoing packets on that port. A not-so desirable trait in time-sensitive networks.\nhttps://www.ieee802.org/1/files/public/docs2015/ASRev-pannell-To-1-step-or-not-0315-v1.pdf ↩︎\n","wordCount":"1376","inLanguage":"en","datePublished":"2023-04-05T00:00:00Z","dateModified":"2023-04-05T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://casan.se/blog/networks/ptp-and-timestamping-methods/"},"publisher":{"@type":"Organization","name":"Casper Andersson","logo":{"@type":"ImageObject","url":"https://casan.se/favicon.svg"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://casan.se/ accesskey=h title="Casper Andersson (Alt + H)">Casper Andersson</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://casan.se/blog title=Blog><span>Blog</span></a></li><li><a href=https://casan.se/docs title=Docs><span>Docs</span></a></li><li><a href=https://casan.se/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://casan.se/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://casan.se/>Home</a>&nbsp;»&nbsp;<a href=https://casan.se/blog/>Blog</a>&nbsp;»&nbsp;<a href=https://casan.se/blog/networks/>Networks</a></div><h1 class=post-title>PTP and timestamping methods</h1><div class=post-meta><span title='2023-04-05 00:00:00 +0000 UTC'>April 5, 2023</span>&nbsp;·&nbsp;7 min</div><ul class=post-tags><li><a href=https://casan.se/tags/networks/>networks</a></li></ul></header><div class=post-content><style type=text/css>pre>code{display:block!important;line-height:1.3rem!important;font-size:1.3rem!important}</style><p>Computers in networks traditionally don&rsquo;t have any knowledge of when other
computers can/will transmit data. Dozens of devices transmitting data whenever
they want will inevitably lead to collisions and congestions at one point or
another, which in turn leads to packets not arriving as soon as they should.
Packets arriving later than intended may affect what the receiver should do with
it. Data can expire. If the timeframe for its usefulness has passed then the
receiver must know this, or else it may perform actions based on old
information. There exist techniques to improve predictability in networks, but
this post will focus on a common understanding of time.</p><p>Clock synchronization across the internet typically uses software timestamping
to make sure your computer clock shows the same as the rest of the world
(disregarding timezones). In a best-case scenario software timestamping can
reach a precision of under a millisecond, but also a worst-case of hundreds of
milliseconds. To the human eye looking at a clock, this appears good enough, but
machines may require much higher precision in certain use cases.</p><h2 id=a-new-level-of-precision>A new level of precision<a hidden class=anchor aria-hidden=true href=#a-new-level-of-precision>#</a></h2><p>The IEEE 1588 standard defines the Precision Time Protocol, also known as PTP.
This protocol allows synchronization of hardware clocks down to nanosecond
precision in a local network. Devices achieve this by timestamping packets they
send and receive and comparing the time, and estimating and adjusting according
to the cable delay. But using software timestamping still limits the precision
due to processor scheduling and other network traffic that creates variation in
the actual transmission time.</p><p>To solve this there exist ethernet ports with support for hardware
timestamping. PTP requires a device to know both the transmission and reception
time. Sending over only the current time from the master clock would make the
slave show an earlier time than the master since the master will have moved forward
by the time the slave has received and adjusted the clock. The participating
devices also need to determine how long delay the wire itself incurs. A long
cable, or even a time-unaware switch, can add noticeable delays (noticeable from
a nanosecond perspective).</p><p>Good! Now we have established the requirement! But how does this help us?</p><p>The synchronization process of a slave clock consists of two steps:</p><ol><li>Getting the current time from a master clock</li><li>Finding the cable delay and adding that to the time received from the master</li></ol><p>Step (1) involves the master sending the current time, taken as close to the
wire as possible, in a <em>Sync</em> packet to the slave. PTP defines two methods for
doing this: one-step and two-step. This is explained in more detail later. The
slave can now update its clock to the provided timestamp. Upon reception, the
packet gets timestamped again. Now the slave has <code>receive_time - transmit_time = offset_from_master</code>. The slave can now adjust its clock to the calculated
offset. Though it has not yet compensated for the cable delay. If PTP only ever
did step (1) the slave would always stay behind the master by <code>cable_delay</code>
time. Devices would then end up further behind the further they are from the
master, and each intermediate switch would add more to that.</p><p>For step (2) the slave sends a <em>Delay_Req</em> (delay request) to the master and
records the transmission time (<code>t1</code>) for itself to use later. The master
timestamps the reception time (<code>t2</code>) of the message and sends that back in a
<em>Delay_Resp</em> (delay response) to the slave.</p><p>Because <code>t1</code> was already <code>cable_delay</code> time behind the master clock, due to the
cable delay on the previous <em>Sync</em> packet, the difference between <code>t1</code> and <code>t2</code>
will now be <code>cable_delay * 2</code>. This means the slave clock should add
<code>(t2-t1)/2</code> to its clock. Now the master and slave clocks have successfully
synchronized. The process will then repeat at regular intervals to make sure
everything stays synchronized.</p><h2 id=software-daemon>Software daemon<a hidden class=anchor aria-hidden=true href=#software-daemon>#</a></h2><p>The hardware only needs to implement the timestamping functionality to support
PTP. But managing these different types of packets, as well as deciding who
should be master and who should be slave, requires software. Usually in the form
of a daemon. Richard Cochran maintains the most popular implementation of PTP in
the project <a href=https://github.com/richardcochran/linuxptp>linuxptp</a>.</p><h2 id=one-step-vs-two-step>One-step vs two-step<a hidden class=anchor aria-hidden=true href=#one-step-vs-two-step>#</a></h2><p>When the hardware receives a packet it will save the timestamp in packet
metadata that can then be fetched by the receiving application. Simple enough!</p><p>The transmission poses more of a challenge since metadata can&rsquo;t be included on
the wire. As mentioned earlier, there exist two methods for handling this. The
simplest one involves sending a packet, taking the timestamp from when it was
sent, and then sending a <em>Follow_Up</em> packet that includes the transmission time
of the first packet. This is called two-step timestamping.</p><p>The other alternative, one-step timestamping, requires hardware that can detect
and modify the right fields in the PTP packets as they go out on the wire. That
way the packet contains the data.</p><p>The following illustration shows the slave clock synchronizing to the master
clock using two-step timestamping. The cable has a delay of 1 time unit.
Described from the point of the master clock&rsquo;s time:</p><pre tabindex=0><code class=language-no-hl data-lang=no-hl>  Master         Slave
      ┌───────────┐
      │           │
   50─┼──────┐    ├─20
      │      │    │
   51─┼────┐ └───►├─21
      │    │      │
   52─┤    └─────►├─22-&gt;51
      │           │
   53─┤     ┌─────┼─52
      │     │     │
   54─┤◄────┘     ├─53
      │           │
   55─┼─────┐     ├─54
      │     │     │
   56─┤     └────►├─55-&gt;56
      │           │
   57─┤           ├─57
      └───────────┘
</code></pre><ol start=50><li>Master sends <em>Sync</em> packet and timestamps it (<code>50</code>).</li><li>Slave receives <em>Sync</em> and timestamps it (<code>21</code>). Master sends <em>Follow_Up</em>
containing the transmission time of <em>Sync</em>.</li><li>Slave receives <em>Follow_Up</em> and calculates the difference between <em>Sync</em>
transmission and reception. <code>50-21=29</code>. Slave updates its clock by
adjusting it <code>+29</code>. <code>22+29=51</code>.</li><li>Slave sends a <em>Delay_Req</em> and timestamps it (<code>52</code>).</li><li>Master receives <em>Delay_Req</em> and timestamps it (<code>54</code>).</li><li>Master sends back the <em>Delay_Req</em> timestamp in a <em>Delay_Resp</em> packet.</li><li>Slave receives <em>Delay_Resp</em>. It now has the timestamps <code>52</code> and <code>54</code>, which
represents the cable delay multiplied by 2. Half comes from the packet
delay request. And the other half comes from the earlier <em>Sync</em> packet
where the slave knowingly set its time to <code>cable_delay</code> behind the master
since it didn&rsquo;t know the delay. The slave adjusts its time by <code>(54-52)/2=1</code>
and moves it <code>1</code> unit forward.</li><li>The clocks are now synced.</li></ol><p>Using one-step works the same, with the only difference that the master does
not need to send a <em>Follow_Up</em> packet.</p><p>Two-step only requires the networking hardware to be capable of timestamping
packets. The timestamping happens either in the MAC hardware or the PHY
hardware. The PHY will provide better accuracy since it allows timestamping to
be the last action before the packet goes on the wire. Performing timestamping
in the MAC can give slightly higher variation in accuracy, but still good
enough for many use cases.</p><p>The following illustration shows an example layout of how a MAC and PHY would
be attached in switching hardware. The PHY attaches directly to the cable.</p><pre tabindex=0><code class=language-no-hl data-lang=no-hl>      ┌───┐
      │CPU│
      └─┬─┘
        │
      ┌─┴─┐
  ┌───┤MAC├───┐
  │   └─┬─┘   │
  │     │     │
┌─┴─┐ ┌─┴─┐ ┌─┴─┐
│PHY│ │PHY│ │PHY│
└▲─▼┘ └▲─▼┘ └▲─▼┘
</code></pre><p>For one-step, the hardware also needs the functionality to modify the packet,
and that includes understanding the PTP packet layout. Using one-step results in
fewer packets to handle and slightly faster convergence (time for all clocks in
the network to get accurately synced) since it never has to wait for a second
packet. Though with the introduction of the standard 802.1AS, it has been shown
that two-step can perform just as well, and the extra traffic on the network
becomes insignificant at the network speeds of today.</p><p>So why doesn&rsquo;t everyone use one-step? At the surface, it looks good, but looking
deeper one-step has some drawbacks. When reaching speeds of 10Gbit and higher it
will incur penalties for the time spent taking the timestamp and modifying the
packet<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. The network transmits fast enough that it takes longer to add the
time than the actual transmission. This means that the hardware can&rsquo;t work at
full wire speed while timestamping just before transmitting. To get around this
the hardware could try to predict the transmission time and prepare the packet
ahead of time. But that too has its issues as preparing ahead of time adds
latency to all outgoing packets on that port. A not-so desirable trait in
time-sensitive networks.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://www.ieee802.org/1/files/public/docs2015/ASRev-pannell-To-1-step-or-not-0315-v1.pdf>https://www.ieee802.org/1/files/public/docs2015/ASRev-pannell-To-1-step-or-not-0315-v1.pdf</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://casan.se/>Casper Andersson</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>