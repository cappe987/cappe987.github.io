<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Synchronization and Syntonization | Casper Andersson</title>
<meta name=keywords content="networks,linux"><meta name=description content="Aligning and keeping clocks aligned"><meta name=author content><link rel=canonical href=https://casan.se/blog/networks/synchronization-and-syntonization/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://casan.se/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://casan.se/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://casan.se/favicon-32x32.png><link rel=apple-touch-icon href=https://casan.se/apple-touch-icon.png><link rel=mask-icon href=https://casan.se/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://casan.se/blog/networks/synchronization-and-syntonization/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://casan.se/blog/"},{"@type":"ListItem","position":2,"name":"Networks","item":"https://casan.se/blog/networks/"},{"@type":"ListItem","position":3,"name":"Synchronization and Syntonization","item":"https://casan.se/blog/networks/synchronization-and-syntonization/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Synchronization and Syntonization","name":"Synchronization and Syntonization","description":"Aligning and keeping clocks aligned","keywords":["networks","linux"],"articleBody":"Setting two clocks to the same time doesn’t seem that hard, right? If same-second precision is enough for you then you can usually do that. But when we are talking nanosecond precision like that provided by PTP (IEEE1588, Precision Time Protocol) there are some more variables to consider.\nSynchronization The first variable to note is the time it takes to set the new time. Even if the action to set the time is triggered at the exact same time, the OS will introduce latency in the operation. Anything that depends on the OS being precise in its operations is out of the question. For this reason the adjustments should be done through adjustments rather than setting an absolute time. By knowing the difference between two clocks the time can be adjusted by that much to synchronize them. Doing this with PTP is explained in this post.\nAssuming the initial difference calculated is precise then this will bring the time difference hopefully within maybe a microsecond.\nSyntonization Now that the clocks are nearly aligned we need to consider the frequency of the oscillators driving the clocks. If two clocks are driven by oscillators at different frequencies, or even just of different qualities, it will result in wander. A big difference will allow significant wander in between every synchronization, resulting in never reaching near-perfect accuracy. When the clocks are within a certain threshold time adjustment can stop and clock syntonization starts. The slave clocks will adjust their operating frequency. Though not literally the frequency, but rather a compensation value the clock will take into account when advancing its time. The frequency is adjusted so the time difference between the clocks approaches 0. If the slave time is behind it needs to increase the frequency gradually until it catches up, at which point it will start fluctuating back and fourth just around the frequency of the master.\nHoldover Clock holdover time is how long it can stay within a certain offset from the master after losing the synchronization (e.g. losing connection). A typical requirement is that it should keep some accuracy during 5 seconds loss. In terms of PTP this may happen if its master clock goes down and it needs to find an new master. And during those 5 seconds while waiting for a new master it cannot drift too far away from the initial time.\nPhysical Hardware Clock When requiring nanosecond-precision timekeeping a hardware clock is used. In Linux this is referred to as a Physical Hardware Clock (PHC). It keeps the time and allows some operations to manage it.\nSet time Get time Adjust time Set frequency Points 1) and 2) are not required by PTP, but are useful for debugging. 3) is the one that is used to adjust for the difference. 4) sets the frequency of the PHC. These operations can be accessed using the phc_ctl tool from the Linuxptp project (along with some more operations).\nIn Linux the PHC are exposed as devices under /dev, typically as /dev/ptpN, where N denotes the number of the PHC.\nSet time The time set is an absolute value in Unix time. Meaning a value of 10 sets the time to 1970-01-01 00:00:10.\nphc_ctl /dev/ptp0 set 10 Get time Reads out the time\nphc_ctl /dev/ptp0 get Adjust time Increments or decrements the clock by the given time in seconds, read as double precision floating point values.\nphc_ctl /dev/ptp0 adj 10.5 Set frequency Sets the frequency of the clock in ppb (parts-per-billion), meaning how many nanoseconds per second it should it should stray from its real frequency. Note that each PHC has different maximum frequency adjustments. The PHC capabilities can be viewed with phc_ctl /dev/ptp0.\nphc_ctl /dev/ptp0 freq 1222 Time scales and leap seconds International Atomic Time (TAI) operates based on a weighted average of over 450 atomic clocks spread out around earth. Universal Coordinated Time (UTC) is based on the actual earths rotation. In TAI a day is defined as having exactly 86 400 seconds, while UTC is subject to leap seconds. Leap seconds occur due to earths rotation speed always changing slightly due to geological or climatic changes, e.g. the continental plates moving or the ice caps melting. Since this cannot be predicted over longer periods a leap second is only announced 6 months in advance.\nThe leap seconds always happen on either June 30th or December 31st at 23:59:59. A leap second ahead is shown as 23:59:60, before advancing to 00:00:00. A leap second backwards goes directly from 23:59:58 to 00:00:00. As for when a leap second occurs, a Linux system should be informed by an NTP daemon when one is scheduled, which in turn gets its time through NTP from a more authoritative clock device.\nPTP operates on the TAI timescale, but always informs of the current UTC offset (37 at the time of writing) to make sure any devices that need the time in UTC can convert to it.\n","wordCount":"822","inLanguage":"en","datePublished":"2023-07-10T00:00:00Z","dateModified":"2023-07-10T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://casan.se/blog/networks/synchronization-and-syntonization/"},"publisher":{"@type":"Organization","name":"Casper Andersson","logo":{"@type":"ImageObject","url":"https://casan.se/favicon.svg"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://casan.se/ accesskey=h title="Casper Andersson (Alt + H)">Casper Andersson</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://casan.se/blog title=Blog><span>Blog</span></a></li><li><a href=https://casan.se/docs title=Docs><span>Docs</span></a></li><li><a href=https://casan.se/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://casan.se/about/ title="About Me"><span>About Me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://casan.se/>Home</a>&nbsp;»&nbsp;<a href=https://casan.se/blog/>Blog</a>&nbsp;»&nbsp;<a href=https://casan.se/blog/networks/>Networks</a></div><h1 class=post-title>Synchronization and Syntonization</h1><div class=post-meta><span title='2023-07-10 00:00:00 +0000 UTC'>July 10, 2023</span>&nbsp;·&nbsp;4 min</div><ul class=post-tags><li><a href=https://casan.se/tags/networks/>Networks</a></li><li><a href=https://casan.se/tags/linux/>Linux</a></li></ul></header><div class=post-content><p>Setting two clocks to the same time doesn&rsquo;t seem that hard, right? If
same-second precision is enough for you then you can usually do that. But when
we are talking nanosecond precision like that provided by PTP (IEEE1588,
Precision Time Protocol) there are some more variables to consider.</p><h2 id=synchronization>Synchronization<a hidden class=anchor aria-hidden=true href=#synchronization>#</a></h2><p>The first variable to note is the time it takes to set the new time. Even if the
action to set the time is triggered at the exact same time, the OS will
introduce latency in the operation. Anything that depends on the OS being
precise in its operations is out of the question. For this reason the
adjustments should be done through adjustments rather than setting an absolute
time. By knowing the difference between two clocks the time can be adjusted by
that much to synchronize them. Doing this with PTP is explained in <a href=https://casan.se/blog/networks/ptp-and-timestamping-methods/>this
post</a>.</p><p>Assuming the initial difference calculated is precise then this will bring the time
difference hopefully within maybe a microsecond.</p><h2 id=syntonization>Syntonization<a hidden class=anchor aria-hidden=true href=#syntonization>#</a></h2><p>Now that the clocks are nearly aligned we need to consider the frequency of the
oscillators driving the clocks. If two clocks are driven by oscillators
at different frequencies, or even just of different qualities, it will result in
wander. A big difference will allow significant wander in between every
synchronization, resulting in never reaching near-perfect accuracy. When the
clocks are within a certain threshold time adjustment can stop and clock
syntonization starts. The slave clocks will adjust their operating frequency.
Though not literally the frequency, but rather a compensation value the clock
will take into account when advancing its time. The frequency is adjusted so
the time difference between the clocks approaches 0. If the slave time is behind
it needs to increase the frequency gradually until it catches up, at which point
it will start fluctuating back and fourth just around the frequency of the
master.</p><h2 id=holdover>Holdover<a hidden class=anchor aria-hidden=true href=#holdover>#</a></h2><p>Clock holdover time is how long it can stay within a certain offset from the
master after losing the synchronization (e.g. losing connection). A typical
requirement is that it should keep some accuracy during 5 seconds loss. In terms
of PTP this may happen if its master clock goes down and it needs to find an new
master. And during those 5 seconds while waiting for a new master it cannot
drift too far away from the initial time.</p><h2 id=physical-hardware-clock>Physical Hardware Clock<a hidden class=anchor aria-hidden=true href=#physical-hardware-clock>#</a></h2><p>When requiring nanosecond-precision timekeeping a hardware clock is used. In
Linux this is referred to as a Physical Hardware Clock (PHC). It keeps the time
and allows some operations to manage it.</p><ol><li>Set time</li><li>Get time</li><li>Adjust time</li><li>Set frequency</li></ol><p>Points 1) and 2) are not required by PTP, but are useful for debugging. 3) is
the one that is used to adjust for the difference. 4) sets the frequency of the
PHC. These operations can be accessed using the <code>phc_ctl</code> tool from the Linuxptp
project (along with some more operations).</p><p>In Linux the PHC are exposed as devices under <code>/dev</code>, typically as <code>/dev/ptpN</code>,
where <code>N</code> denotes the number of the PHC.</p><h3 id=set-time>Set time<a hidden class=anchor aria-hidden=true href=#set-time>#</a></h3><p>The time set is an absolute value in Unix time. Meaning a value of 10 sets the
time to 1970-01-01 00:00:10.</p><pre tabindex=0><code>phc_ctl /dev/ptp0 set 10
</code></pre><h3 id=get-time>Get time<a hidden class=anchor aria-hidden=true href=#get-time>#</a></h3><p>Reads out the time</p><pre tabindex=0><code>phc_ctl /dev/ptp0 get
</code></pre><h3 id=adjust-time>Adjust time<a hidden class=anchor aria-hidden=true href=#adjust-time>#</a></h3><p>Increments or decrements the clock by the given time in seconds, read as double
precision floating point values.</p><pre tabindex=0><code>phc_ctl /dev/ptp0 adj 10.5
</code></pre><h3 id=set-frequency>Set frequency<a hidden class=anchor aria-hidden=true href=#set-frequency>#</a></h3><p>Sets the frequency of the clock in ppb (parts-per-billion), meaning how many
nanoseconds per second it should it should stray from its real frequency. Note
that each PHC has different maximum frequency adjustments. The PHC capabilities
can be viewed with <code>phc_ctl /dev/ptp0</code>.</p><pre tabindex=0><code>phc_ctl /dev/ptp0 freq 1222
</code></pre><h2 id=time-scales-and-leap-seconds>Time scales and leap seconds<a hidden class=anchor aria-hidden=true href=#time-scales-and-leap-seconds>#</a></h2><p>International Atomic Time (TAI) operates based on a weighted average of over 450
atomic clocks spread out around earth. Universal Coordinated Time (UTC) is based
on the actual earths rotation. In TAI a day is defined as having exactly 86 400
seconds, while UTC is subject to leap seconds. Leap seconds occur due to earths
rotation speed always changing slightly due to geological or climatic changes,
e.g. the continental plates moving or the ice caps melting. Since this cannot be
predicted over longer periods a leap second is only announced 6 months in
advance.</p><p>The leap seconds always happen on either June 30th or December 31st at 23:59:59.
A leap second ahead is shown as 23:59:60, before advancing to 00:00:00. A leap
second backwards goes directly from 23:59:58 to 00:00:00. As for when a leap
second occurs, a Linux system should be informed by an NTP daemon when one is
scheduled, which in turn gets its time through NTP from a more authoritative
clock device.</p><p>PTP operates on the TAI timescale, but always informs of the current UTC offset
(37 at the time of writing) to make sure any devices that need the time in UTC
can convert to it.</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://casan.se/>Casper Andersson</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>