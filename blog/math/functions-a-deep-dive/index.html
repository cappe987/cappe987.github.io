<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Functions: a deep dive | Casper Andersson</title>
<meta name=keywords content="math,programming,computer_science"><meta name=description content="Programming functions from a mathematical perspective."><meta name=author content><link rel=canonical href=https://casan.se/blog/math/functions-a-deep-dive/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script src=/js/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=stylesheet href=/css/default.min.css><link rel=icon href=https://casan.se/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://casan.se/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://casan.se/favicon-32x32.png><link rel=apple-touch-icon href=https://casan.se/apple-touch-icon.png><link rel=mask-icon href=https://casan.se/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Functions: a deep dive"><meta property="og:description" content="Programming functions from a mathematical perspective."><meta property="og:type" content="article"><meta property="og:url" content="https://casan.se/blog/math/functions-a-deep-dive/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2021-07-25T00:00:00+00:00"><meta property="article:modified_time" content="2021-07-25T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Functions: a deep dive"><meta name=twitter:description content="Programming functions from a mathematical perspective."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://casan.se/blog/"},{"@type":"ListItem","position":2,"name":"Math","item":"https://casan.se/blog/math/"},{"@type":"ListItem","position":3,"name":"Functions: a deep dive","item":"https://casan.se/blog/math/functions-a-deep-dive/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Functions: a deep dive","name":"Functions: a deep dive","description":"Programming functions from a mathematical perspective.","keywords":["math","programming","computer_science"],"articleBody":" In this post we will take a closer look at functions and some mathematical concepts relating to them. This post assumes you are familiar working with functions in some programming language and some mathematical knowledge of functions as well (like knowing what \\(y = f(x)\\) means and what a set is).\nTerminology and notation Before getting into the main topic I want to cover some terminology and notation. Sets are denoted as an uppercase letter in math-style font like \\(A\\). When I say that an element maps to another it is simply a way of saying that some element \\(x\\), when given as argument to \\(f\\) will return an element \\(y\\), or as an equation \\(y = f(x)\\), \\(x\\) maps to \\(y\\). A transformation from \\(x\\) to \\(y\\). A function/mapping is simply a transformation from one thing to another. One goes in, another goes out.\nIt is also good to know the mathematical notation for the types of a function. \\(f : A \\rightarrow B\\) represents a function \\(f\\) that takes a single argument of type \\(A\\) and returns a value of type \\(B\\). To be more accurate, \\(A\\) and \\(B\\) aren’t types, but rather a set of possible values that can be input/output. But in the world of programming we often represent them as types like int, string, float, or similar. For example, the \\(log\\) function could be written as \\(log : \\mathbb{R}^+ \\rightarrow \\mathbb{R}\\), which means all positive real numbers as input and all real numbers as output. Although in the programming world it would instead be written as \\(log : \\text{float} \\rightarrow \\text{float}\\). \\(A\\) is called the domain. \\(B\\) is called the codomain. If we want to be more exact we use the term range to indicate all possible values that \\(f\\) can return. Which means that the range is a subset of the codomain. For example, for the function \\(f(x) = x^2\\) we can say it has the codomain \\(\\mathbb{R}\\), but if you inspect the function you will see that the range is only \\(\\mathbb{R}^+\\), only the positive real numbers since the function can never return any negative numbers.\nDeterminism and the definition of a function Going strictly by the mathematical definition we don’t have any reference types (pointers) and no void functions. A function must always return a value for any element that is in its domain. Exceptions like values that will cause division by zero or other undefined computations will not be in that domain and are expected to not be put into the function. To be able to make any useful arguments regarding a function we must also require it to be pure.\nThe concept of pure functions only exist in the programming world, because in the world of math every function is pure. A pure function is one where the the return value only depends on the arguments. There cannot be any side effects. The function cannot print or write any values to external memory, and cannot read any values from the outside. These are what we call side-effects, inputs/outputs that are not the function arguments and return value. If we allow side-effects then the function becomes inherently non-deterministic, unpredictable. From here on when I say input I mean the arguments and output means return value. The simplest pure function we can have is the “constant function”. It takes 0 arguments and returns the same value every time it is called. Since we can’t have any side-effects that is all a function with no input can do. Below is an example of a constant function (written in Python). As you can see, if we don’t have any arguments there is no data to work with if we aren’t allowed side-effects.\ndef pi(): return 3.14159265359 This may seem restricting, but determinism in itself is a very useful property for a function. The same input will always give the same output. It’s very easy to test as it doesn’t depend on any state, which also makes it easier to debug. If you have some logical mistake in a deterministic function then all you need to do is find the mistake inside that function (assuming the input is correct, otherwise the issue is elsewhere). If it is non-deterministic function then you may need to look at all state that it is working with to find what goes wrong. You may need to debug much more outside of the function in question to find what leads to the invalid state.\nIf you don’t care about the formal definition then just skip to the next section. A formal definition is that a function \\(f : A \\rightarrow B\\) maps every element in a set \\(A\\) to some element in a set \\(B\\), and each element in \\(A\\) can only map to a single element in \\(B\\). This means that for any value \\(x \\in A\\), \\(f(x)\\) must always be the same value. Or expressed as a logical statement below: if \\(f(x)\\) returns two values \\(y_1\\) and \\(y_2\\) from the same \\(x\\) then \\(y_1 = y_2\\).\n\\( \\forall x. x \\in A. y_1 = f(x) \\wedge y_2 = f(x) \\implies y_1 = y_2 \\)\nIf the return values were different then that would contradict the definition of a function and it would also break the purity and determinism. If \\(y_1\\) and \\(y_2\\) are different for the same \\(x\\) then the function obviously has side-effects.\nInjective, surjective, and bijective An injective function is a function \\(f : A \\rightarrow B\\) where no two elements in \\(A\\) returns the same element in \\(B\\). This is a function that is reversible because each value in the range has only one corresponding value in the domain. But that is only true for the range. Every value \\(y = f(x)\\) can be reversed to get back \\(x\\), but not every value in the codomain. The codomain may be a superset of the range, so there may be elements in the codomain that do not have any corresponding element in the domain. Some properties that derive from this is that the sets of the domain and range must be the same size, and the codomain must be equal or greater than the domain.\nA surjective function is the opposite of an injective. All elements in the codomain must be return values of some input to \\(f\\). Which means that the range = codomain. But the domain can be larger than the codomain since multiple elements of \\(A\\) can map to the same element of \\(B\\). There is no guarantee that the elements in \\(B\\) can be reversed since there may be several values of \\(A\\) that can give that output.\nBijective functions are functions that are both injective and surjective. When we put those two together we get a function that is a one-to-one mapping between the domain and codomain. It is always reversible in both directions and you can always create an inverse function that gives back the original (usually denoted \\(f^{-1}\\), where \\(f^{-1}(f(x)) = x\\)). Inverse operations can be useful when you want to undo something you have previously done or when you need to find out what the original was. For example, addition and subtraction are inverses. If we have \\(f(x) = x + 5\\) then the inverse of that is \\(f^{-1}(x) = x - 5\\).\nWhile bijective functions have a clear use-case of inverse operations, injective and surjective functions may be harder to find a good use for. Although it can be something to keep in mind when programming as they have some unique properties which you may be able to use for something.\nChaining functions When we have functions that always return values and have well-defined domains and codomains then we can easily chain them. This is called function composition. In mathematical notation it looks like this \\( g \\circ f\\), which simply means \\(g(f(x))\\). But to do this the functions must have matching domains and codomains. If \\(f : A \\rightarrow B\\) then we must have \\(g : B \\rightarrow C\\) to be able to chain them. So if \\(h = g \\circ f\\) then \\(h : A \\rightarrow C\\) since it performs both \\(f\\) and \\(g\\). Composing functions like this is very good for creating a long pipeline of transformations. And if we stick to using deterministic functions then it becomes very clean looking code and the different components get separated into distinct parts where one returns what the next needs. When chaining functions it is important to keep track on the domain and range of your functions. If \\(g\\) can return a value that \\(f\\) cannot take as input then you have a problem.\nThe concept of chaining can be applied on reference types as well. It requires every method to return self or this or whatever your language calls the reference an object has to itself. So you could call methods like x.f().g().h() and so on, where each method modifies the internal structure as if those were the arguments. This is commonly seen in the builder pattern (C# example below). The non-object-oriented equivalent of that is h(g(f(x))), where x could just as well just be an object that holds some variables. The problem with determinism and purity in object oriented programming comes when a method both modifies the internal state and returns a separate value. Because at that point it has changed some state that is separate from the return value.\nHumanBuilder builder = new HumanBuilder(); Human human = builder.AddHead().AddBody().AddArms().AddLegs().Build(); There is nothing wrong with non-deterministic functions. Non-determinism is required to make any interesting program. And a lot of object oriented programming revolves around changing state. It just takes a different approach than the mathematical side. Although I do encourage you to write as much deterministic code as possible.\nOther types of mappings Dictionaries, HashMaps, HashDictionaries, and the like are all mappings from one set to another. The key is the input and the value is the output. And as long as you don’t modify them they are deterministic. Although modifying them are often a key feature of using them. They may not be considered functions, but they are definitely relations, a superset of functions. A relation is just a mapping from one element to another, often denoted (1,2) when 1 maps to 2 (in function notation: \\(2 = f(1)\\)). Although relations are often represented as whole sets of mappings to indicate all possible relations like \\({(1,2), (2,3), (3,4), (4,5)}\\) to indicate a subset of the function \\(f(x) = x + 1\\) for integers.\nSwitch statements are also a type of mapping, and a function, from some variable value to a block of code. If that block of code is just a function that returns its value then you have a mapping from a value to a function (C# example below).\nswitch (x){ case 1 : return f(); case 2 : return g(); default: return h(); } Everything stated here extends easily to functions with multiple arguments or multiple return values, usually denoted as tuples. Although deciding if such functions are injective or surjective may become much harder. The notation for such a function is \\(f : A \\times B \\rightarrow C \\times D\\), where \\(A \\times B\\) means the Cartesian product of the sets \\(A\\) and \\(B\\). Meaning all possible combinations of the elements of the two sets. When you have multiple arguments the domain increases a whole lot in size, since now every element in \\(A\\) can be paired with every element in \\(B\\). The total domain size becomes \\(\\vert A \\vert \\times \\vert B \\vert\\) (size of \\(A\\) multiplied by size of \\(B\\)).\nFunctions and relations are everywhere in programming. In places you never considered before. Even your browser is a mapping that takes a URL and returns a webpage. Keep an eye out for them and see if you can use that knowledge to write cleaner and better code, and maybe catch some bugs.\n","wordCount":"1983","inLanguage":"en","datePublished":"2021-07-25T00:00:00Z","dateModified":"2021-07-25T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://casan.se/blog/math/functions-a-deep-dive/"},"publisher":{"@type":"Organization","name":"Casper Andersson","logo":{"@type":"ImageObject","url":"https://casan.se/favicon.svg"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://casan.se/ accesskey=h title="Casper Andersson (Alt + H)">Casper Andersson</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://casan.se/blog title=Blog><span>Blog</span></a></li><li><a href=https://casan.se/docs title=Docs><span>Docs</span></a></li><li><a href=https://casan.se/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://casan.se/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://casan.se/>Home</a>&nbsp;»&nbsp;<a href=https://casan.se/blog/>Blog</a>&nbsp;»&nbsp;<a href=https://casan.se/blog/math/>Math</a></div><h1 class=post-title>Functions: a deep dive</h1><div class=post-meta>&lt;span title='2021-07-25 00:00:00 +0000 UTC'>July 25, 2021&lt;/span>&amp;nbsp;·&amp;nbsp;10 min</div><ul class=post-tags><li><a href=https://casan.se/tags/math/>math</a></li><li><a href=https://casan.se/tags/programming/>programming</a></li><li><a href=https://casan.se/tags/computer_science/>computer_science</a></li></ul></header><div class=post-content><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js></script><p>In this post we will take a closer look at functions and some mathematical
concepts relating to them. This post assumes you are familiar working with
functions in some programming language and some mathematical knowledge of
functions as well (like knowing what \(y = f(x)\) means and what a set is).</p><h2 id=terminology-and-notation>Terminology and notation<a hidden class=anchor aria-hidden=true href=#terminology-and-notation>#</a></h2><p>Before getting into the main topic I want to cover some terminology and
notation. Sets are denoted as an uppercase letter in math-style font like
\(A\). When I say that an element <strong>maps</strong> to another it is simply a way of
saying that some element \(x\), when given as argument to \(f\) will return an
element \(y\), or as an equation \(y = f(x)\), \(x\) maps to \(y\). A
<strong>transformation</strong> from \(x\) to \(y\). A function/mapping is simply a
transformation from one thing to another. One goes in, another goes out.</p><p>It is also good to know the mathematical notation for the types of a function.
\(f : A \rightarrow B\) represents a function \(f\) that takes a single
argument of type \(A\) and returns a value of type \(B\). To be more accurate,
\(A\) and \(B\) aren&rsquo;t types, but rather a set of possible values that can be
input/output. But in the world of programming we often represent them as types
like <code>int</code>, <code>string</code>, <code>float</code>, or similar. For example, the \(log\) function
could be written as \(log : \mathbb{R}^+ \rightarrow \mathbb{R}\), which means
all positive real numbers as input and all real numbers as output. Although in
the programming world it would instead be written as \(log : \text{float}
\rightarrow \text{float}\). \(A\) is called the <strong>domain</strong>. \(B\) is called the
<strong>codomain</strong>. If we want to be more exact we use the term <strong>range</strong> to indicate
all possible values that \(f\) can return. Which means that the range is a
subset of the codomain. For example, for the function \(f(x) = x^2\) we can say
it has the codomain \(\mathbb{R}\), but if you inspect the function you will
see that the range is only \(\mathbb{R}^+\), only the positive real numbers
since the function can never return any negative numbers.</p><h2 id=determinism-and-the-definition-of-a-function>Determinism and the definition of a function<a hidden class=anchor aria-hidden=true href=#determinism-and-the-definition-of-a-function>#</a></h2><p>Going strictly by the mathematical definition we don&rsquo;t have any reference types
(pointers) and no <code>void</code> functions. A function must always return a value for
any element that is in its domain. Exceptions like values that will cause
division by zero or other undefined computations will not be in that domain and
are expected to not be put into the function. To be able to make any useful
arguments regarding a function we must also require it to be <strong>pure</strong>.</p><p>The concept of pure functions only exist in the programming world, because in
the world of math every function is pure. A pure function is one where the the
return value only depends on the arguments. There cannot be any side effects.
The function cannot print or write any values to external memory, and cannot
read any values from the outside. These are what we call side-effects,
inputs/outputs that are not the function arguments and return value. If we
allow side-effects then the function becomes inherently non-deterministic,
unpredictable. From here on when I say input I mean the arguments and output
means return value. The simplest pure function we can have is the &ldquo;constant
function&rdquo;. It takes 0 arguments and returns the same value every time it is
called. Since we can&rsquo;t have any side-effects that is all a function with no
input can do. Below is an example of a constant function (written in Python).
As you can see, if we don&rsquo;t have any arguments there is no data to work with if
we aren&rsquo;t allowed side-effects.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=k>def</span> <span class=nf>pi</span><span class=p>():</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mf>3.14159265359</span>
</span></span></code></pre></div><p>This may seem restricting, but determinism in itself is a very useful property
for a function. The same input will always give the same output. It&rsquo;s very easy
to test as it doesn&rsquo;t depend on any state, which also makes it easier to debug.
If you have some logical mistake in a deterministic function then all you need
to do is find the mistake inside that function (assuming the input is correct,
otherwise the issue is elsewhere). If it is non-deterministic function then you
may need to look at all state that it is working with to find what goes wrong.
You may need to debug much more outside of the function in question to find
what leads to the invalid state.</p><p>If you don&rsquo;t care about the formal definition then just skip to the next
section. A formal definition is that a function \(f : A \rightarrow B\) maps
every element in a set \(A\) to some element in a set \(B\), and each
element in \(A\) can only map to a single element in \(B\). This means that
for any value \(x \in A\), \(f(x)\) must always be the same value. Or
expressed as a logical statement below: if \(f(x)\) returns two values
\(y_1\) and \(y_2\) from the same \(x\) then \(y_1 = y_2\).</p><p>\( \forall x. x \in A. y_1 = f(x) \wedge y_2 = f(x) \implies y_1 = y_2 \)</p><p>If the return values were different then that would contradict the definition
of a function and it would also break the purity and determinism. If \(y_1\)
and \(y_2\) are different for the same \(x\) then the function obviously has
side-effects.</p><h2 id=injective-surjective-and-bijective>Injective, surjective, and bijective<a hidden class=anchor aria-hidden=true href=#injective-surjective-and-bijective>#</a></h2><p>An injective function is a function \(f : A \rightarrow B\) where no two
elements in \(A\) returns the same element in \(B\). This is a function that is
reversible because each value in the range has only one corresponding value in
the domain. But that is only true for the range. Every value \(y = f(x)\) can
be reversed to get back \(x\), but not every value in the codomain. The
codomain may be a superset of the range, so there may be elements in the
codomain that do not have any corresponding element in the domain. Some
properties that derive from this is that the sets of the domain and range must
be the same size, and the codomain must be equal or greater than the domain.</p><p>A surjective function is the opposite of an injective. All elements in the
codomain must be return values of some input to \(f\). Which means that the
range = codomain. But the domain can be larger than the codomain since multiple
elements of \(A\) can map to the same element of \(B\). There is no guarantee
that the elements in \(B\) can be reversed since there may be several values of
\(A\) that can give that output.</p><p>Bijective functions are functions that are both injective and surjective. When
we put those two together we get a function that is a one-to-one mapping
between the domain and codomain. It is always reversible in both directions and
you can always create an inverse function that gives back the original (usually
denoted \(f^{-1}\), where \(f^{-1}(f(x)) = x\)). Inverse operations can be
useful when you want to undo something you have previously done or when you
need to find out what the original was. For example, addition and subtraction
are inverses. If we have \(f(x) = x + 5\) then the inverse of that is
\(f^{-1}(x) = x - 5\).</p><p>While bijective functions have a clear use-case of inverse operations,
injective and surjective functions may be harder to find a good use for.
Although it can be something to keep in mind when programming as they have some
unique properties which you may be able to use for something.</p><h2 id=chaining-functions>Chaining functions<a hidden class=anchor aria-hidden=true href=#chaining-functions>#</a></h2><p>When we have functions that always return values and have well-defined domains
and codomains then we can easily chain them. This is called function
composition. In mathematical notation it looks like this \( g \circ f\), which
simply means \(g(f(x))\). But to do this the functions must have matching
domains and codomains. If \(f : A \rightarrow B\) then we must have \(g : B
\rightarrow C\) to be able to chain them. So if \(h = g \circ f\) then \(h : A
\rightarrow C\) since it performs both \(f\) and \(g\). Composing functions
like this is very good for creating a long pipeline of transformations. And if
we stick to using deterministic functions then it becomes very clean looking
code and the different components get separated into distinct parts where one
returns what the next needs. When chaining functions it is important to keep
track on the domain and range of your functions. If \(g\) can return a value
that \(f\) cannot take as input then you have a problem.</p><p>The concept of chaining can be applied on reference types as well. It requires
every method to return <code>self</code> or <code>this</code> or whatever your language calls the
reference an object has to itself. So you could call methods like
<code>x.f().g().h()</code> and so on, where each method modifies the internal structure as
if those were the arguments. This is commonly seen in the builder pattern (C#
example below). The non-object-oriented equivalent of that is <code>h(g(f(x)))</code>,
where <code>x</code> could just as well just be an object that holds some variables. The
problem with determinism and purity in object oriented programming comes when a
method both modifies the internal state and returns a separate value. Because
at that point it has changed some state that is separate from the return value.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=n>HumanBuilder</span> <span class=n>builder</span> <span class=p>=</span> <span class=k>new</span> <span class=n>HumanBuilder</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>Human</span> <span class=n>human</span> <span class=p>=</span> <span class=n>builder</span><span class=p>.</span><span class=n>AddHead</span><span class=p>().</span><span class=n>AddBody</span><span class=p>().</span><span class=n>AddArms</span><span class=p>().</span><span class=n>AddLegs</span><span class=p>().</span><span class=n>Build</span><span class=p>();</span>
</span></span></code></pre></div><p>There is nothing wrong with non-deterministic functions. Non-determinism is
required to make any interesting program. And a lot of object oriented
programming revolves around changing state. It just takes a different approach
than the mathematical side. Although I do encourage you to write as much
deterministic code as possible.</p><h2 id=other-types-of-mappings>Other types of mappings<a hidden class=anchor aria-hidden=true href=#other-types-of-mappings>#</a></h2><p>Dictionaries, HashMaps, HashDictionaries, and the like are all mappings from
one set to another. The key is the input and the value is the output. And as
long as you don&rsquo;t modify them they are deterministic. Although modifying them
are often a key feature of using them. They may not be considered functions,
but they are definitely relations, a superset of functions. A relation is just
a mapping from one element to another, often denoted (1,2) when 1 maps to 2 (in
function notation: \(2 = f(1)\)). Although relations are often represented as
whole sets of mappings to indicate all possible relations like \({(1,2),
(2,3), (3,4), (4,5)}\) to indicate a subset of the function \(f(x) = x + 1\)
for integers.</p><p>Switch statements are also a type of mapping, and a function, from some
variable value to a block of code. If that block of code is just a function
that returns its value then you have a mapping from a value to a function (C#
example below).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=k>switch</span> <span class=p>(</span><span class=n>x</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=m>1</span> <span class=p>:</span> <span class=k>return</span> <span class=n>f</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=m>2</span> <span class=p>:</span> <span class=k>return</span> <span class=n>g</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>default</span><span class=p>:</span> <span class=k>return</span> <span class=n>h</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Everything stated here extends easily to functions with multiple arguments or
multiple return values, usually denoted as tuples. Although deciding if such
functions are injective or surjective may become much harder. The notation for
such a function is \(f : A \times B \rightarrow C \times D\), where \(A \times
B\) means the Cartesian product of the sets \(A\) and \(B\). Meaning all
possible combinations of the elements of the two sets. When you have multiple
arguments the domain increases a whole lot in size, since now every element in
\(A\) can be paired with every element in \(B\). The total domain size becomes
\(\vert A \vert \times \vert B \vert\) (size of \(A\) multiplied by size of
\(B\)).</p><p>Functions and relations are everywhere in programming. In places you never
considered before. Even your browser is a mapping that takes a URL and returns
a webpage. Keep an eye out for them and see if you can use that knowledge to
write cleaner and better code, and maybe catch some bugs.</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://casan.se/>Casper Andersson</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>