<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Operators are functions too | Casper Andersson</title><meta name=keywords content="programming"><meta name=description content="Viewing operators as functions and functions as operators."><meta name=author content><link rel=canonical href=https://casan.se/blog/operators-are-functions-too/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script src=/js/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=stylesheet href=/css/default.min.css><link rel=icon href=https://casan.se/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://casan.se/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://casan.se/favicon-32x32.png><link rel=apple-touch-icon href=https://casan.se/apple-touch-icon.png><link rel=mask-icon href=https://casan.se/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Operators are functions too"><meta property="og:description" content="Viewing operators as functions and functions as operators."><meta property="og:type" content="article"><meta property="og:url" content="https://casan.se/blog/operators-are-functions-too/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2019-12-09T00:00:00+00:00"><meta property="article:modified_time" content="2019-12-09T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Operators are functions too"><meta name=twitter:description content="Viewing operators as functions and functions as operators."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://casan.se/blog/"},{"@type":"ListItem","position":2,"name":"Operators are functions too","item":"https://casan.se/blog/operators-are-functions-too/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Operators are functions too","name":"Operators are functions too","description":"Viewing operators as functions and functions as operators.","keywords":["programming"],"articleBody":"Introduction Most programming languages today have a bunch of operators for different purposes. Usually for mathematical, logical, comparison, and bitwise operations. +, -, *, /, \u0026\u0026, ||, exists in probably every modern language. Developers expect them to exist; no one would want to program without them.\nMany languages like to extend their operators, usually +, to work on several types. Python allows using the plus operator on both strings and numbers. The interpreter accepts both \"AB\" + \"CD\" and 3 + 5; but these are not the same operation, just the same operator. Addition on numbers is commutative, 3 + 5 == 5 + 3; addition on strings is not, \"A\" + \"B\" != \"B\" + \"A\".\nOperator:\na symbol or function denoting an operation (e.g. ×, +).\nOperation:\nan action to be performed on some data.\nLanguages do this through operator overloading, either built in to the compiler/interpreter, or as a part of the actual language. You specify what operation an operator should do for a specific class/type. While integer addition adds up the numbers, string addition (also known as concatenation) appends the second string to the end of the first to create a new string. If you do add any yourself, you shouldn’t give them completely different behavior than what the symbol usually means. Using the + operator on Vectors shouldn’t perform a cross product just because you thought it seemed convenient.\nOperators as functions You may think of operators as these magical symbols that the developers programmed into the language. While partially true, you can also see an operator as a infix function (excluding Lisp, where everything is prefix). Think of \u003e as a function. What parameters does it have and what does it return?\nClick to expand: greater-than type signature {% highlight fsharp %} (int -\u003e int -\u003e bool) {% endhighlight %} In a more familiar style: {% highlight csharp %} bool greaterThan(int a, int b); {% endhighlight %} This is not accounting for any other possible operator overloading, such as strings or other number types (eg. float/double). Some programming languages lets you treat operators like a function. In the code snippet below, we assign the plus operation to the function addition\naddition = (+) -- (int -\u003e int -\u003e int) addition 3 5 -- returns 8 Haskell also lets you treat regular functions as infix function.\n3 `addition` 5 -- returns 8 You can usually express operators in terms of other operators. In C you can define + and - using bitwise operators; and in turn you can define * and / with those. Assuming you have other language constructs such as loops and if-statements available. Integer equality and comparison can be expressed with the help of subtraction. Logical operators can be expressed with equality.\nAt the time of writing this I am currently working on making an interpreter for my own Lisp-like language. I was having some trouble figuring out how to handle the operators. Do I treat them as functions? Or is it better to see them as operators and parse them as such? To minimize the amount of operators I realized I could define the logical operators with the help of only the equality operator; and could thus put them in the standard library for the language. A few less operators to worry about. Unfortunately I couldn’t take it any further than that; as the language I’m making is rather high-level. The rest of the standard operators are hardcoded in the parser, but are parsed as function calls to allow for easier partial application and less types to worry about.\nbool and(bool a, bool b){ if(a == true){ if(b == true){ return true; } } return false; } Defining your own operators Once again, only some languages allow defining custom operators. When talking about operators I am speficially talking about binary operators in this context. An example of a unary operator (one argument) is - when placed right in front of a numerical to create a negative number a = -2. A ternary operator (three arugments) commonly exists in the form of a one line if-else statement condition ? when true : when false. Less common operators like unary and ternary have their uses, but not in this post.\nDefining your own operators has no logical benefit in the sense that it changes the way your program works. You could consider it syntactic sugar, but it can improve readability a lot. If you find yourself in a project where you are using a certain functionality a lot, you can consider if you want to make a custom operator. The symbols I chose for the example below has no meaning in any context that I am aware of, other than that they are legal symbols for custom operators in Haskell.\nadd5div a b = (a + 5) / (b + 5) ( \u003c@\u003e ) a b = add5div a b 10 \u003c@\u003e 5 -- returns 1.5 Haskell has a bunch of code-defined operators in the standard libary to help with certain actions in its very intricate type system. For example: $, \u003c$\u003e, \u003c*\u003e, and \u003e\u003e=.\nDefining custom operators is more common in functional programming languages than imperative ones. Imperative has all these state-manipulating statements and function calls, while in functional languages everything is done by composing functions, which makes operators very useful. Instead of passing two different data into a function as arguments, you use that function as an operator to make it look more elegant. Function calls become less cluttered and, if you are familiar with the operator, easier to read.\n","wordCount":"929","inLanguage":"en","datePublished":"2019-12-09T00:00:00Z","dateModified":"2019-12-09T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://casan.se/blog/operators-are-functions-too/"},"publisher":{"@type":"Organization","name":"Casper Andersson","logo":{"@type":"ImageObject","url":"https://casan.se/favicon.svg"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://casan.se/ accesskey=h title="Casper Andersson (Alt + H)">Casper Andersson</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://casan.se/blog title=Blog><span>Blog</span></a></li><li><a href=https://casan.se/docs title=Docs><span>Docs</span></a></li><li><a href=https://casan.se/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://casan.se/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://casan.se/>Home</a>&nbsp;»&nbsp;<a href=https://casan.se/blog/>Blog</a></div><h1 class=post-title>Operators are functions too</h1><div class=post-meta><span title='2019-12-09 00:00:00 +0000 UTC'>December 9, 2019</span>&nbsp;·&nbsp;5 min</div><ul class=post-tags><li><a href=https://casan.se/tags/programming/>programming</a></li></ul></header><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>Most programming languages today have a bunch of operators for different purposes. Usually for mathematical, logical, comparison, and bitwise operations. <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>&&</code>, <code>||</code>, exists in probably every modern language. Developers expect them to exist; no one would want to program without them.</p><p>Many languages like to extend their operators, usually <code>+</code>, to work on several types. Python allows using the plus operator on both strings and numbers. The interpreter accepts both <code>"AB" + "CD"</code> and <code>3 + 5</code>; but these are not the same operation, just the same operator. Addition on numbers is commutative, <code>3 + 5 == 5 + 3</code>; addition on strings is not, <code>"A" + "B" != "B" + "A"</code>.</p><p><strong>Operator:</strong></p><blockquote><p>a symbol or function denoting an operation (e.g. ×, +).</p></blockquote><p><strong>Operation:</strong></p><blockquote><p>an action to be performed on some data.</p></blockquote><p>Languages do this through operator overloading, either built in to the compiler/interpreter, or as a part of the actual language. You specify what operation an operator should do for a specific class/type. While integer addition adds up the numbers, string addition (also known as concatenation) appends the second string to the end of the first to create a new string. If you do add any yourself, you shouldn&rsquo;t give them completely different behavior than what the symbol usually means. Using the <code>+</code> operator on Vectors shouldn&rsquo;t perform a cross product just because you thought it seemed convenient.</p><h2 id=operators-as-functions>Operators as functions<a hidden class=anchor aria-hidden=true href=#operators-as-functions>#</a></h2><p>You may think of operators as these magical symbols that the developers programmed into the language. While partially true, you can also see an operator as a infix function (excluding Lisp, where everything is prefix). Think of <code>></code> as a function. What parameters does it have and what does it return?</p><details class=details><summary class=summary>Click to expand: greater-than type signature</summary>
{% highlight fsharp %}
(int -> int -> bool)
{% endhighlight %}
In a more familiar style:
{% highlight csharp %}
bool greaterThan(int a, int b);
{% endhighlight %}
This is not accounting for any other possible operator overloading,
such as strings or other number types (eg. float/double).</details><br><p>Some programming languages lets you treat operators like a function. In the code snippet below, we assign the plus operation to the function <code>addition</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-hs data-lang=hs><span class=line><span class=cl><span class=nf>addition</span> <span class=ow>=</span> <span class=p>(</span><span class=o>+</span><span class=p>)</span> <span class=c1>-- (int -&gt; int -&gt; int)</span>
</span></span><span class=line><span class=cl><span class=nf>addition</span> <span class=mi>3</span> <span class=mi>5</span> <span class=c1>-- returns 8</span>
</span></span></code></pre></div><p>Haskell also lets you treat regular functions as infix function.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-hs data-lang=hs><span class=line><span class=cl><span class=mi>3</span> <span class=p>`</span><span class=n>addition</span><span class=p>`</span> <span class=mi>5</span> <span class=c1>-- returns 8</span>
</span></span></code></pre></div><p>You can usually express operators in terms of other operators. In C you can define <code>+</code> and <code>-</code> using bitwise operators; and in turn you can define <code>*</code> and <code>/</code> with those. Assuming you have other language constructs such as loops and if-statements available. Integer equality and comparison can be expressed with the help of subtraction. Logical operators can be expressed with equality.</p><p>At the time of writing this I am currently working on making an interpreter for my own Lisp-like language. I was having some trouble figuring out how to handle the operators. Do I treat them as functions? Or is it better to see them as operators and parse them as such? To minimize the amount of operators I realized I could define the logical operators with the help of only the equality operator; and could thus put them in the standard library for the language. A few less operators to worry about. Unfortunately I couldn&rsquo;t take it any further than that; as the language I&rsquo;m making is rather high-level. The rest of the standard operators are hardcoded in the parser, but are parsed as function calls to allow for easier partial application and less types to worry about.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=kt>bool</span> <span class=n>and</span><span class=p>(</span><span class=kt>bool</span> <span class=n>a</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>b</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>a</span> <span class=p>==</span> <span class=k>true</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>b</span> <span class=p>==</span> <span class=k>true</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=k>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=k>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=defining-your-own-operators>Defining your own operators<a hidden class=anchor aria-hidden=true href=#defining-your-own-operators>#</a></h2><p>Once again, only some languages allow defining custom operators. When talking about operators I am speficially talking about binary operators in this context. An example of a unary operator (one argument) is <code>-</code> when placed right in front of a numerical to create a negative number <code>a = -2</code>. A ternary operator (three arugments) commonly exists in the form of a one line if-else statement <code>condition ? when true : when false</code>. Less common operators like unary and ternary have their uses, but not in this post.</p><p>Defining your own operators has no logical benefit in the sense that it changes the way your program works. You could consider it syntactic sugar, but it can improve readability a lot. If you find yourself in a project where you are using a certain functionality a lot, you can consider if you want to make a custom operator. The symbols I chose for the example below has no meaning in any context that I am aware of, other than that they are legal symbols for custom operators in Haskell.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-hs data-lang=hs><span class=line><span class=cl><span class=nf>add5div</span> <span class=n>a</span> <span class=n>b</span> <span class=ow>=</span> <span class=p>(</span><span class=n>a</span> <span class=o>+</span> <span class=mi>5</span><span class=p>)</span> <span class=o>/</span> <span class=p>(</span><span class=n>b</span> <span class=o>+</span> <span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span> <span class=o>&lt;@&gt;</span> <span class=p>)</span> <span class=n>a</span> <span class=n>b</span> <span class=ow>=</span> <span class=n>add5div</span> <span class=n>a</span> <span class=n>b</span>
</span></span><span class=line><span class=cl><span class=mi>10</span> <span class=o>&lt;@&gt;</span> <span class=mi>5</span> <span class=c1>-- returns 1.5</span>
</span></span></code></pre></div><p>Haskell has a bunch of code-defined operators in the standard libary to help with certain actions in its very intricate type system. For example: <code>$</code>, <code>&lt;$></code>, <code>&lt;*></code>, and <code>>>=</code>.</p><p>Defining custom operators is more common in functional programming languages than imperative ones. Imperative has all these state-manipulating statements and function calls, while in functional languages everything is done by composing functions, which makes operators very useful. Instead of passing two different data into a function as arguments, you use that function as an operator to make it look more elegant. Function calls become less cluttered and, if you are familiar with the operator, easier to read.</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://casan.se/>Casper Andersson</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>